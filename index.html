<!DOCTYPE html>
<html lang="ar" dir="ltr">
<head>
  <meta charset="UTF-8">
  <title>ğŸ® Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Poppins:wght@200;400;500;600;700;800;900&display=swap");
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: "Poppins", sans-serif; }
    body { display: flex; justify-content: center; align-items: center; min-height: 100vh; background: url("https://i.pinimg.com/originals/d7/b9/0c/d7b90cc80898e8823455a127945719af.jpg") no-repeat; background-size: cover; background-position: center; overflow-y: auto; position: relative; 
    }

    /* --- Sidebar Styles --- */
    .sidebar-toggle {
        position: fixed;
        top: 15px;
        right: 20px; 
        font-size: 2.2rem;
        color: white;
        background-color: #002b4d;
        border: none;
        padding: 5px 10px;
        border-radius: 8px;
        cursor: pointer;
        z-index: 1002; 
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .sidebar-toggle:focus { outline: none; }

    .sidebar {
        height: 100%;
        width: 0; 
        position: fixed;
        z-index: 1001;
        top: 0;
        right: 0; 
        background-color: #00233a; 
        overflow-x: hidden;
        transition: 0.35s ease-out;
        padding-top: 70px; 
        direction: rtl;
        box-shadow: -5px 0 15px rgba(0,0,0,0.2); 
    }
    .sidebar.open {
        width: 260px; 
    }
    .sidebar a {
        padding: 12px 15px 12px 30px; 
        text-decoration: none;
        font-size: 1.15rem;
        color: #b0bec5; 
        display: block;
        transition: 0.2s;
        border-bottom: 1px solid #002b4d; 
    }
    .sidebar a:last-child {
        border-bottom: none;
    }
    .sidebar a:hover, .sidebar a.active-nav-link {
        color: #fff;
        background-color: #003B73;
        font-weight: bold;
    }
    .sidebar .sidebar-close-btn {
        position: absolute;
        top: 15px;
        left: 25px; 
        font-size: 2rem;
        color: #b0bec5;
        cursor: pointer;
    }
     .sidebar .sidebar-close-btn:hover {
        color: #fff;
     }

    #admin-button-sidebar {
        background-color: rgba(220, 53, 69, 0.7);
        color: white !important; 
    }
    #admin-button-sidebar:hover {
         background-color: #dc3545;
    }

    /* --- General Styles --- */
    .wrapper { margin-top: 80px; width: 420px; background-color: transparent; border: 2px solid rgba(255, 255, 255, 0.2); backdrop-filter: blur(15px); box-shadow: 0 0 10px rgba(0, 0, 0, 0.2); color: #fff; border-radius: 16px; padding: 20px 30px; direction: rtl; }
    .wrapper h1 { font-size: 30px; text-align: center; margin-bottom:20px;}
    .wrapper .input-box { width: 100%; height: 50px; position: relative; margin: 20px 0; } /* Adjusted margin */
    .input-box input { width: 100%; height: 100%; background: transparent; border: none; outline: none; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 40px; font-size: 16px; color: #fff; padding: 20px 45px 20px 20px; text-align: right; direction: rtl; }
    .input-box input::placeholder { color: #fff; text-align: right; }
    .input-box i { position: absolute; top: 50%; transform: translateY(-50%); font-size: 20px; left: 20px; }
    .wrapper .remember-forgot { display: flex; justify-content: space-between; font-size: 14px; margin: -15px 0 15px; direction: rtl; }
    .remember-forgot label input { accent-color: #fff; margin-left: 3px; }
    .remember-forgot a { color: #fff; text-decoration: none; }
    .remember-forgot a:hover { text-decoration: underline; }
    .wrapper .btn { width: 100%; height: 45px; background: #fff; border: none; outline: none; border-radius: 40px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); cursor: pointer; font-size: 16px; color: #333; font-weight: 600; margin-top: 15px; display: flex; align-items: center; justify-content: center;}
    .wrapper .btn:disabled { background: #aaa; color: #666; cursor: not-allowed; }
    .wrapper .register-link { text-align: center; font-size: 14px; margin: 20px 0 15px; }
    .wrapper .register-link p a { color: #fff; text-decoration: none; font-weight: 600; }
    .wrapper .register-link p a:hover { text-decoration: underline; }

    #auth-status { margin-top:10px; padding: 8px; border-radius: 8px; font-weight: 500; min-height: 1.5em; text-align: center; color: #fff; font-size: 0.9em;}
    #auth-status.success { background-color: rgba(40, 167, 69, 0.3); border: 1px solid rgba(40, 167, 69, 0.6); }
    #auth-status.error { background-color: rgba(220, 53, 69, 0.3); border: 1px solid rgba(220, 53, 69, 0.6); }
    #auth-status.info { background-color: rgba(23, 162, 184, 0.3); border: 1px solid rgba(23, 162, 184, 0.6); }
    
    #phone-verification-section { margin-top: 15px; padding-top:15px; border-top: 1px solid rgba(255,255,255,0.2);}
    #recaptcha-container { margin: 10px auto; }


    nav#main-nav { display: none; } 
    
    section { display: none; padding: 20px; max-width: 600px; margin: 20px auto; margin-top: 80px; background: rgba(255, 255, 255, 0.95); color: #333; border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15); direction: rtl; }
    section.active { display:block !important; } 
    section#login.active, section#game-launcher.active { background: transparent; box-shadow: none; border: none; padding: 0; max-width: none; } 
    section#game-launcher.active { margin-top: 80px; padding: 20px; }
    section h2 { margin-top: 0; color: #003B73; text-align: center; margin-bottom: 20px; }
    section#game-launcher h2 { color: #fff; font-size: 2rem; margin-bottom: 30px; }
    section:not(#login):not(#game-launcher) button { padding:10px 15px; margin:8px 4px; font-size:0.9rem; cursor:pointer; border:none; border-radius:8px; background:#005A9C; color:white; transition:background .2s; }
    section#xo .xo-options button, section#memory .memory-options button { font-size: 0.9rem; padding: 10px 12px;} 
    section:not(#login):not(#game-launcher) button:hover { background:#003B73; }
    section:not(#login):not(#game-launcher) button:disabled { background:#ccc; cursor:not-allowed; }
    .status, .result, .message, .timebox { margin:15px 0; font-size:1.1rem; min-height: 1.2em; text-align: center;}
    
    .game-controls { margin-top: 15px; text-align: center; } 

    .xo-board-container { position: relative; width: 316px; height: 316px; margin: 0 auto 20px auto; }
    .board { display:grid; grid-template-columns:repeat(3,100px); gap:8px; justify-content:center; }
    .cell { width:100px; height:100px; border:2px solid #aaa; display:flex; align-items:center; justify-content:center; font-size:2.8rem; background:#f9f9f9; transition:background .2s; cursor:pointer; border-radius: 8px; color: #333; }
    .cell:hover { background:#e9e9e9; }
    #xo-winning-line-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    .xo-options, .memory-options { margin-bottom: 15px; text-align: center; }
    .xo-options button, .memory-options button { margin: 0 3px; } 

    .gamebox, .cards { margin: 0 auto 20px auto; text-align: center; }
    .cards { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; max-width: 380px; }
    .cards.disabled { pointer-events: none; }
    .cards.disabled .card:not(.matched) { opacity: 0.8; }

    .card { width: 80px; height: 80px; background-color: #007bff; color: white; display: flex; align-items: center; justify-content: center; font-size: 2rem; border-radius: 8px; cursor: pointer; transition: transform 0.3s, background-color 0.3s; transform-style: preserve-3d; }
    .card .card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; align-items: center; justify-content: center; border-radius: 8px; }
    .card .card-front { background-color: #005A9C; } 
    .card .card-back { background-color: #f0f0f0; color: #333; transform: rotateY(180deg); }
    .card.flipped { transform: rotateY(180deg); }
    .card.matched { background-color: #28a745 !important; cursor: default; opacity: 0.7; }
    .card.matched .card-front { background-color: #28a745 !important; } 
    .memory-scores { margin-bottom: 10px; font-weight: bold; }
    .memory-player-names-input { margin-bottom:15px; text-align:center; }
    .memory-player-names-input input { padding:8px; margin:0 5px; border-radius:5px; border:1px solid #ccc; text-align:center;}

    #click-target-area { text-align: left; min-height: 200px; background-color: #e9ecef; position: relative; border-radius: 8px; overflow: hidden; }
    #clickable-target { width: 50px; height: 50px; background-color: red; border-radius: 50%; position: absolute; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; transition: all 0.1s; }
    .timebox { padding: 20px; background-color: #6c757d; color: white; border-radius: 8px; font-size: 1.5rem; cursor: pointer; transition: background-color 0.3s; }
    .timebox.waiting { background-color: #dc3545; } 
    .timebox.ready { background-color: #28a745; } 

    .text-to-type { padding: 15px; border: 1px solid #ccc; border-radius: 8px; margin-bottom: 15px; font-size: 1.1rem; line-height: 1.6; background-color: #f8f9fa; direction: rtl; text-align: right; }
    #typing-input { width: 100%; padding: 10px; font-size: 1rem; border-radius: 8px; border: 1px solid #ccc; direction: rtl; text-align: right; }
    .input-group { text-align: center; } 
    .input-group input { margin: 0 auto 10px auto; display: block; max-width: 250px; text-align: center; padding:10px; border-radius: 8px; border:1px solid #ccc; }

    .hidden-by-auth { display: none !important; } 
    .button-text { margin: 0 5px; }

    .game-icons-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 25px; padding: 20px; max-width: 800px; margin: 0 auto; }
    .game-icon-card { background-color: rgba(0, 43, 77, 0.6); border: 1px solid rgba(255, 255, 255, 0.25); border-radius: 12px; padding: 20px 15px; text-align: center; cursor: pointer; transition: transform 0.25s ease-out, box-shadow 0.25s ease-out, background-color 0.25s; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 130px; backdrop-filter: blur(5px); }
    .game-icon-card:hover { transform: translateY(-8px) scale(1.03); box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35); background-color: rgba(0, 60, 110, 0.7); }
    .game-icon-card i { font-size: 3.5rem; margin-bottom: 12px; color: #cce7ff; transition: color 0.2s; }
    .game-icon-card:hover i { color: #fff; }
    .game-icon-card span { color: #fff; font-size: 1rem; font-weight: 500; }

    #settings p { margin-bottom: 10px; font-size: 1.1rem; }
    #settings .info-value { font-weight: bold; color: #005A9C; }
    #settings-status { margin-top: 15px; font-size: 0.9em; }

    #admin-area h3 { margin-top: 20px; margin-bottom: 10px; color: #003B73; }
    #admin-users-list-container ul { list-style: none; padding: 0; }
    #admin-users-list-container li { background-color: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; margin-bottom: 8px; border-radius: 6px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
    #admin-users-list-container li span { margin-right: 10px; word-break: break-all; }
    #admin-users-list-container li .user-actions button { font-size: 0.8rem; padding: 5px 8px; margin-left: 5px;}
    #admin-user-details-container p { margin-bottom: 5px; }
    .banned-user-indicator { color: red; font-weight: bold; }

  </style>
</head>
<body>

  <button class="sidebar-toggle" id="sidebar-toggle-button">
    <i class='bx bx-menu'></i>
  </button>

  <div class="sidebar" id="mySidebar">
    <a href="javascript:void(0)" class="sidebar-close-btn" id="sidebar-close-button">Ã—</a>
    <a href="#login" id="nav-login-link-sidebar">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</a>
    <a href="#game-launcher" id="nav-games-launcher-link-sidebar" style="display:none;">Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨</a>
    <a href="#settings" id="nav-settings-link-sidebar" style="display:none;">Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</a>
    <a href="#" id="admin-button-sidebar" style="display:none;" onclick="showAdminArea(event)">Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ø¯Ù…Ù†</a>
  </div>

  <section id="login">
    <div class="wrapper">
        <form action="javascript:void(0);">
            <h1 id="login-title">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</h1>
            <div id="auth-form-fields">
                <div class="input-box">
                    <input type="email" placeholder="Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ" id="login-email" required>
                    <i class='bx bxs-user'></i>
                </div>
                <div class="input-box">
                    <input type="password" placeholder="ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±" id="login-password" required>
                    <i class='bx bxs-lock-alt'></i>
                </div>
            </div>

            <!-- Ù‚Ø³Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ (ÙŠØ¸Ù‡Ø± Ø¹Ù†Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯ Ø¨Ø¹Ø¯ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ ÙˆØ§Ù„Ø¨Ø§Ø³ÙˆÙˆØ±Ø¯) -->
            <div id="phone-verification-section" style="display:none;">
                <h4>Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ (Ø¥Ù„Ø²Ø§Ù…ÙŠ)</h4>
                <div class="input-box">
                    <input type="tel" placeholder="Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ (Ù…Ø«Ø§Ù„: +201001234567)" id="phone-number-input">
                    <i class='bx bxs-phone'></i>
                </div>
                <button type="button" class="btn" id="btn-send-otp">Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚</button>
                <div id="recaptcha-container"></div>
                
                <div id="otp-input-section" style="display:none; margin-top:15px;">
                     <div class="input-box">
                        <input type="text" placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ (OTP)" id="otp-code-input">
                        <i class='bx bxs-key'></i>
                    </div>
                    <button type="button" class="btn" id="btn-verify-otp">Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒÙˆØ¯</button>
                </div>
                <div id="phone-auth-status" class="info" style="margin-top:10px;"></div>
            </div>

            <button type="button" class="btn" id="btn-main-action">
                 <span class="button-text">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</span>
            </button>
            <div class="register-link">
                <p id="toggle-auth-mode-text">Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ØŸ <a href="#" id="toggle-auth-mode-link-inner">Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨</a></p>
            </div>
            <button type="button" class="btn" id="btn-logout" style="display:none; margin-top: 10px;">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬</button>
        </form>
        <div id="auth-status" class="info">ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£Ùˆ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯.</div>
    </div>
  </section>

  <section id="game-launcher">
    <h2>Ø§Ø®ØªØ± Ù„Ø¹Ø¨ØªÙƒ Ø§Ù„Ù…ÙØ¶Ù„Ø©!</h2>
    <div class="game-icons-grid" id="game-icons-grid-container">
    </div>
  </section>

  <section id="xo" class="game-section"> 
    <h2>Ø¥ÙƒØ³ Ø£Ùˆ (XO)</h2>
    <div class="xo-options">
        <button id="xo-pvp">Ù„Ø§Ø¹Ø¨ Ø¶Ø¯ Ù„Ø§Ø¹Ø¨</button>
        <button id="xo-pvc-hard">Ù„Ø§Ø¹Ø¨ Ø¶Ø¯ ÙƒÙ…Ø¨ÙŠÙˆØªØ± (ØµØ¹Ø¨)</button> 
    </div>
    <div class="xo-board-container">
        <div class="board"></div> 
        <canvas id="xo-winning-line-canvas"></canvas>
    </div>
    <div class="status">Ø§Ø®ØªØ± Ù†Ù…Ø· Ø§Ù„Ù„Ø¹Ø¨Ø©</div> 
    <div class="game-controls">
        <button id="xo-restart" style="display:none;">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©</button> 
        <button id="xo-exit-game" style="display:none;">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button>
    </div>
  </section>

  <section id="memory" class="game-section"> 
    <h2>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© ğŸ§ </h2> 
    <div class="memory-options">
        <button id="memory-pvp">Ù„Ø§Ø¹Ø¨ Ø¶Ø¯ Ù„Ø§Ø¹Ø¨</button>
        <button id="memory-solo">Ù„Ø§Ø¹Ø¨ ÙˆØ§Ø­Ø¯</button>
    </div>
    <div class="memory-player-names-input" style="display:none;">
        <input type="text" id="memory-player1-name" placeholder="Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ 1">
        <input type="text" id="memory-player2-name" placeholder="Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ 2">
        <button id="memory-start-pvp-named">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
    </div>
    <div class="memory-scores" style="display:none;">
        <span id="memory-player1-score">Ø§Ù„Ù„Ø§Ø¹Ø¨ 1: 0</span>
        <span id="memory-player2-separator" style="display:none;"> | </span>
        <span id="memory-player2-score" style="display:none;">Ø§Ù„Ù„Ø§Ø¹Ø¨ 2: 0</span>
    </div>
    <div class="cards" style="display:none;"></div> 
    <div class="status">Ø§Ø®ØªØ± Ù†Ù…Ø· Ø§Ù„Ù„Ø¹Ø¨Ø©</div> 
    <div class="gamebox game-controls">
        <button id="memory-restart" style="display:none;">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
        <button id="memory-exit-game" style="display:none;">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button>
    </div> 
  </section>
  
  <section id="settings" class="game-section">
      <h2>Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª âš™ï¸</h2>
      <p>Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ: <span id="settings-user-email" class="info-value"></span></p>
      <p>Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ: <span id="settings-user-phone" class="info-value">Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚</span></p>
      <button id="btn-change-password">ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</button>
      <div id="settings-status" class="info"></div>
  </section>

  <section id="admin-area" class="game-section" style="display:none;">
      <h2>Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù† ğŸ‘‘</h2>
      <p>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ Ø£ÙŠÙ‡Ø§ Ø§Ù„Ø£Ø¯Ù…Ù†!</p>
      
      <div id="admin-users-section">
          <h3>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</h3>
          <p><strong>Ù…Ù„Ø§Ø­Ø¸Ø©:</strong> "Ø§Ù„Ø­Ø¸Ø±" Ù‡Ù†Ø§ Ù‡Ùˆ Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ (ÙŠÙ…Ù†Ø¹ Ø§Ù„Ù„Ø¹Ø¨)ØŒ ÙˆÙ„Ø§ ÙŠØ­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ù† Firebase Authentication.</p>
          <div id="admin-users-list-container">
              <p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...</p>
          </div>
          <div id="admin-user-details-container" style="display:none; margin-top:15px; padding:10px; border:1px solid #ccc; border-radius:8px;">
              <h4>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:</h4>
              <p id="details-email"></p>
              <p id="details-uid"></p>
              <p id="details-created"></p>
              <p id="details-last-login"></p>
              <p id="details-phone"></p>
              <p id="details-banned-status"></p>
              <button id="details-close-btn">Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªÙØ§ØµÙŠÙ„</button>
          </div>
      </div>
      <div id="admin-status" class="info" style="margin-top: 20px;"></div>
  </section>


  <section id="rps" class="game-section"> <h2>Ø­Ø¬Ø± ÙˆØ±Ù‚Ø© Ù…Ù‚Øµ ğŸ§±ğŸ“„âœ‚ï¸</h2> <div class="gamebox"> <button data-choice="ğŸ§±">ğŸ§±</button> <button data-choice="ğŸ“„">ğŸ“„</button> <button data-choice="âœ‚ï¸">âœ‚ï¸</button> </div> <div class="result">Ø§Ø®ØªØ± Ù„Ø¨Ø¯Ø¡!</d> <div class="game-controls"><button id="rps-exit-game">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button></div> </section>
  <section id="click" class="game-section"> <h2>Ø§ØµØ·ÙŠØ§Ø¯ Ø§Ù„Ù‡Ø¯Ù ğŸ¯</h2> <div class="gamebox"><button id="click-start">Ø§Ø¨Ø¯Ø£</button> <button id="click-exit-game" style="display:none;">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button> </div> <div id="click-target-area" class="gamebox" style="display:none;"></div> <div class="status">Ø§Ø¶ØºØ· "Ø§Ø¨Ø¯Ø£"</div> </section>
  <section id="react" class="game-section"> <h2>Ø§Ø®ØªØ¨Ø§Ø± Ø³Ø±Ø¹Ø© Ø§Ù„Ø¶ØºØ· âŒ›</h2> <div class="timebox" id="react-box">Ø§Ø¶ØºØ· Ù„Ù„Ø¨Ø¯Ø¡</div> <div class="game-controls" style="margin-top:5px;"><button id="react-exit-game">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button></div></section>
  <section id="dice" class="game-section"> <h2>Ù„Ø¹Ø¨Ø© Ø§Ù„Ù†Ø±Ø¯ ğŸ²</h2> <div class="gamebox"><button id="dice-roll">Ø±Ù…ÙŠ Ø§Ù„Ù†Ø±Ø¯</button> <button id="dice-exit-game">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button></div> <div class="result" id="dice-result" style="font-size: 3rem;">--</div> </section>
  <section id="math" class="game-section"> <h2>Ø¬Ù…Ø¹ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ğŸ§®</h2> <div class="gamebox"><button id="math-start">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©</button> <button id="math-exit-game" style="display:none;">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button></div> <div class="question-area" style="display:none; font-size: 1.5rem; margin-bottom: 15px; text-align:center;"></div> <div class="input-group" style="display:none;"> <input type="number" id="math-answer" placeholder="Ø£Ø¯Ø®Ù„ Ø¥Ø¬Ø§Ø¨ØªÙƒ"/> <button id="math-submit">ØªØ­Ù‚Ù‚</button> </div> <div class="result">--</div> </section>
  <section id="guessnum" class="game-section"> <h2>ØªØ®Ù…ÙŠÙ† Ø§Ù„Ø±Ù‚Ù… ğŸ”¢</h2> <div class="gamebox"><button id="guessnum-start">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©</button> <button id="guessnum-exit-game" style="display:none;">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button></div> <div class="input-group" style="display:none;"> <input type="number" id="guessnum-input" placeholder="Ø®Ù…Ù† Ø¨ÙŠÙ† 1 Ùˆ100"/> <button id="guessnum-submit">Ø®Ù…Ù†</button> </div> <div class="result">--</div> <div class="message">Ø®Ù…Ù† Ø±Ù‚Ù…Ù‹Ø§ Ø¨ÙŠÙ† 1 Ùˆ 100</div> </section>
  <section id="bigsmall" class="game-section"> <h2>Ù…Ù† Ø§Ù„Ø£ÙƒØ¨Ø±ØŸ ğŸ“</h2> <div class="gamebox"><button id="bigsmall-start">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©</button> <button id="bigsmall-exit-game" style="display:none;">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button></div> <div class="question-area" style="display:none; font-size: 1.5rem; margin-bottom: 15px; text-align:center;"></div> <div class="input-group" style="display:none;"> <input type="number" id="bigsmall-answer" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø£ÙƒØ¨Ø±"/> <button id="bigsmall-submit">ØªØ­Ù‚Ù‚</button> </div> <div class="result">--</div> </section>
  <section id="typing" class="game-section"> <h2>Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ÙƒØªØ§Ø¨Ø© âŒ¨ï¸</h2> <div class="gamebox"><button id="typing-start">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±</button> <button id="typing-exit-game" style="display:none;">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button></div> <div class="text-to-type" style="display:none;"></div> <div class="input-group" style="display:none;"> <input type="text" id="typing-input" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ù‡Ù†Ø§"/> <button id="typing-submit">ØªØ­Ù‚Ù‚</button> </div> <div class="status">--</div> </section>


  <audio id="snd-click" src="https://actions.google.com/sounds/v1/alarms/button_click.ogg"></audio>
  <audio id="snd-win" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg"></audio>
  <audio id="snd-lose" src="https://actions.google.com/sounds/v1/cartoon/cartoon_cowbell.ogg"></audio>

  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>


  <script>
    const firebaseConfig = {
        apiKey: "AIzaSyDLzpa2HYzJZdZvY_YuviKZ6Zg0FhWTfJw", 
        authDomain: "my-site-cdd00.firebaseapp.com",
        projectId: "my-site-cdd00",
        storageBucket: "my-site-cdd00.firebasestorage.app",
        messagingSenderId: "514123463555",
        appId: "1:514123463555:web:8499c5bde152537a3dd4b6",
        measurementId: "G-3Y7SYCE0NZ"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore(); 
    const ADMIN_EMAIL = "ka6761386@gmail.com"; 
    let currentUserIsAdmin = false; 
    let tempUserCredentialForPhoneAuth = null; // Ù„ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¤Ù‚ØªÙ‹Ø§

    document.addEventListener('DOMContentLoaded', () => {
      const playSound = (id) => { const s = document.getElementById(id); if (s) { s.currentTime = 0; s.play().catch(e => console.warn(`Sound ${id} play failed:`, e)); } };
      const updateButtonText = (buttonElement, baseText) => { if (buttonElement) { const textSpan = buttonElement.querySelector('.button-text') || document.createElement('span'); textSpan.className = 'button-text'; textSpan.textContent = baseText; buttonElement.innerHTML = ''; buttonElement.appendChild(textSpan); }};
      const updateElementText = (el, txt, type) => { if(el) { el.textContent = txt; const baseClasses = el.className.split(' ').filter(c => !['info','success','error','waiting','ready'].includes(c)).join(' '); el.className = baseClasses; if (type) el.classList.add(type); }};
      const showHideElement = (el, show, disp = 'block') => { if(el) el.style.display = show ? disp : 'none'; };
      const disableElement = (el, dis) => { if(el) el.disabled = dis; };

      const allSections = document.querySelectorAll('section');
      const sidebar = document.getElementById('mySidebar');
      const sidebarToggleButton = document.getElementById('sidebar-toggle-button');
      const sidebarCloseButton = document.getElementById('sidebar-close-button');
      
      const navLoginLinkSidebar = document.getElementById('nav-login-link-sidebar');
      const navGamesLauncherLinkSidebar = document.getElementById('nav-games-launcher-link-sidebar');
      const navSettingsLinkSidebar = document.getElementById('nav-settings-link-sidebar');
      const adminButtonSidebar = document.getElementById('admin-button-sidebar');

      const gameLauncherSection = document.getElementById('game-launcher');
      const gameIconsGridContainer = document.getElementById('game-icons-grid-container');
      
      const gameNavLinksData = [ 
          { id: "xo", text: "Ø¥ÙƒØ³ Ø£Ùˆ", icon: "bxs-grid-alt" }, 
          { id: "rps", text: "Ø­Ø¬Ø± ÙˆØ±Ù‚Ø© Ù…Ù‚Øµ", icon: "bxs-joystick-button" },
          { id: "click", text: "Ø§ØµØ·ÙŠØ§Ø¯ Ø§Ù„Ù‡Ø¯Ù", icon: "bxs-bullseye" }, 
          { id: "react", text: "Ø³Ø±Ø¹Ø© Ø§Ù„Ø¶ØºØ·", icon: "bxs-stopwatch" },
          { id: "dice", text: "Ø§Ù„Ù†Ø±Ø¯", icon: "bxs-dice-5" }, 
          { id: "memory", text: "Ø§Ù„Ø°Ø§ÙƒØ±Ø©", icon: "bxs-brain" },
          { id: "math", text: "Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª", icon: "bxs-calculator" }, 
          { id: "guessnum", text: "ØªØ®Ù…ÙŠÙ† Ø§Ù„Ø±Ù‚Ù…", icon: "bxs-help-circle" },
          { id: "bigsmall", text: "Ù…Ù† Ø§Ù„Ø£ÙƒØ¨Ø±", icon: "bxs-sort-alt" }, 
          { id: "typing", text: "Ø§Ù„ÙƒØªØ§Ø¨Ø©", icon: "bxs-keyboard" }
      ];
      let isLoginMode = true;

      const loginTitle = document.getElementById('login-title');
      const mainActionButton = document.getElementById('btn-main-action');
      const toggleAuthModeText = document.getElementById('toggle-auth-mode-text');
      const authFormFields = document.getElementById('auth-form-fields');
      const loginEmailInput = document.getElementById('login-email');
      const loginPasswordInput = document.getElementById('login-password');
      const btnLogout = document.getElementById('btn-logout');
      const authStatusDiv = document.getElementById('auth-status');

      const phoneVerificationSection = document.getElementById('phone-verification-section');
      const phoneNumberInput = document.getElementById('phone-number-input');
      const btnSendOtp = document.getElementById('btn-send-otp');
      const otpInputSection = document.getElementById('otp-input-section');
      const otpCodeInput = document.getElementById('otp-code-input');
      const btnVerifyOtp = document.getElementById('btn-verify-otp');
      const phoneAuthStatusDiv = document.getElementById('phone-auth-status');
      const recaptchaContainer = document.getElementById('recaptcha-container');


      const settingsUserEmailEl = document.getElementById('settings-user-email');
      const settingsUserPhoneEl = document.getElementById('settings-user-phone');
      const btnChangePassword = document.getElementById('btn-change-password');
      const settingsStatusDiv = document.getElementById('settings-status');

      const adminUsersListContainer = document.getElementById('admin-users-list-container');
      const adminUserDetailsContainer = document.getElementById('admin-user-details-container');
      const adminStatusDiv = document.getElementById('admin-status');
      const detailsCloseBtn = document.getElementById('details-close-btn');
      if (detailsCloseBtn) detailsCloseBtn.addEventListener('click', () => showHideElement(adminUserDetailsContainer, false));

      // ØªÙ‡ÙŠØ¦Ø© reCAPTCHA
      let recaptchaVerifier = null;
      const setupRecaptcha = () => {
        if (recaptchaVerifier) { //  ØªØ¬Ù†Ø¨ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„
            try {
                 grecaptcha.reset(window.recaptchaWidgetId); //  Ø¬Ø±Ø¨ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙˆÙŠØ¯Ø¬Øª Ø§Ù„Ø­Ø§Ù„ÙŠ
            } catch (e) {
                 console.warn("Could not reset existing reCAPTCHA, re-rendering:", e);
                 if (recaptchaContainer) recaptchaContainer.innerHTML = ''; // Ø¥ÙØ±Ø§Øº Ø§Ù„Ø­Ø§ÙˆÙŠØ© Ù‚Ø¨Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡
                 recaptchaVerifier = null; // Ø§Ø³Ù…Ø­ Ø¨Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡
            }
        }
        if (!recaptchaVerifier && recaptchaContainer && recaptchaContainer.offsetParent !== null) { // ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø­Ø§ÙˆÙŠØ© Ù…Ø±Ø¦ÙŠØ©
            recaptchaVerifier = new firebase.auth.RecaptchaVerifier(recaptchaContainer, {
                'size': 'invisible',
                'callback': (response) => {
                    // console.log("reCAPTCHA verified");
                },
                'expired-callback': () => {
                    updateElementText(phoneAuthStatusDiv, 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© reCAPTCHA. Ø­Ø§ÙˆÙ„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', 'error');
                    if (window.recaptchaWidgetId) grecaptcha.reset(window.recaptchaWidgetId);
                }
            });
            recaptchaVerifier.render().then(function(widgetId) {
                window.recaptchaWidgetId = widgetId;
            }).catch(err => {
                console.error("Recaptcha render error:", err);
                updateElementText(phoneAuthStatusDiv, "Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© reCAPTCHA. ØªØ£ÙƒØ¯ Ø£Ù†Ùƒ Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª ÙˆØ£Ù† Ø§Ù„Ù†Ø·Ø§Ù‚ Ù…Ø¶Ø§Ù Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ø§ ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ÙØªØ§Ø­ reCAPTCHA.", "error");
            });
        }
      };


      const updateUserDocument = (user, phoneNumber = null, phoneVerified = false) => {
          if (!user) return;
          const userDocRef = db.collection('users').doc(user.uid);
          const userData = {
              email: user.email,
              uid: user.uid,
              displayName: user.displayName || user.email.split('@')[0],
              lastLogin: firebase.firestore.FieldValue.serverTimestamp(),
              createdAt: user.metadata.creationTime ? firebase.firestore.Timestamp.fromDate(new Date(user.metadata.creationTime)) : firebase.firestore.FieldValue.serverTimestamp(),
              isBanned: false,
              phoneVerified: phoneVerified,
          };
          if (phoneNumber) {
              userData.phoneNumber = phoneNumber;
          }

          userDocRef.set(userData, { merge: true }) 
          .then(() => {
              userDocRef.get().then(doc => {
                  if (doc.exists && doc.data().isAdmin === true) {
                      currentUserIsAdmin = true;
                  } else {
                      currentUserIsAdmin = false;
                  }
                  showHideElement(adminButtonSidebar, currentUserIsAdmin && user.emailVerified && doc.data().phoneVerified);
                  if(settingsUserPhoneEl && doc.exists) settingsUserPhoneEl.textContent = doc.data().phoneNumber ? `${doc.data().phoneNumber} (${doc.data().phoneVerified ? 'Ù…ÙØªØ­Ù‚Ù‚' : 'ØºÙŠØ± Ù…ÙØªØ­Ù‚Ù‚'})` : 'Ù„Ù… ÙŠÙØ¶ÙÙ';
              }).catch(err => {
                  console.error("Error fetching user admin status:", err);
                  currentUserIsAdmin = false; 
                  showHideElement(adminButtonSidebar, false);
              });
          })
          .catch(error => {
              console.error("Error updating user document in Firestore: ", error);
          });
      };
      
      const checkIfUserIsBanned = async (userId) => {
          if (!userId) return false;
          try {
              const userDoc = await db.collection('users').doc(userId).get();
              if (userDoc.exists && userDoc.data().isBanned === true) {
                  return true;
              }
              return false;
          } catch (error) {
              console.error("Error checking ban status:", error);
              return false; 
          }
      };
       const checkUserPhoneVerified = async (userId) => {
          if (!userId) return false;
          try {
              const userDoc = await db.collection('users').doc(userId).get();
              return userDoc.exists && userDoc.data().phoneVerified === true;
          } catch (error) {
              console.error("Error checking phone verification status:", error);
              return false;
          }
      };


       const updateAuthUI = async (isLoggedIn, user, isVerified = true) => {
        showHideElement(authFormFields, !isLoggedIn);
        showHideElement(mainActionButton, !isLoggedIn);
        showHideElement(toggleAuthModeText.parentElement, !isLoggedIn);
        showHideElement(btnLogout, isLoggedIn); 
        showHideElement(phoneVerificationSection, false); // Ø¥Ø®ÙØ§Ø¡ Ù‚Ø³Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù…Ø¨Ø¯Ø¦ÙŠÙ‹Ø§

        showHideElement(navLoginLinkSidebar, true); 
        
        let isBanned = false;
        let phoneIsVerified = false;

        if (isLoggedIn && user) {
            isBanned = await checkIfUserIsBanned(user.uid);
            if (isBanned) {
                updateElementText(authStatusDiv, `Ø­Ø³Ø§Ø¨Ùƒ (${user.email}) Ù…Ø­Ø¸ÙˆØ±. Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø£Ù„Ø¹Ø§Ø¨.`, 'error');
                isVerified = false; 
                 if (auth.currentUser) { 
                    await auth.signOut().catch(e => console.warn("Error signing out banned user", e));
                    return; 
                }
            }
            phoneIsVerified = await checkUserPhoneVerified(user.uid);
        }
        
        const canAccessContent = isLoggedIn && isVerified && phoneIsVerified;
        showHideElement(navGamesLauncherLinkSidebar, canAccessContent);
        showHideElement(navSettingsLinkSidebar, canAccessContent);
        
        const currentActiveSection = document.querySelector('section.active');
        const activeSectionId = currentActiveSection ? currentActiveSection.id : 'login';

        if (isLoggedIn) {
          loginTitle.textContent = `Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ`;
          if (isVerified && phoneIsVerified) { 
            updateElementText(authStatusDiv, user.email, 'success');
            if(gameIconsGridContainer && gameIconsGridContainer.children.length === 0) populateGameLauncher();
            if(settingsUserEmailEl) settingsUserEmailEl.textContent = user.email;
            updateUserDocument(user, user.phoneNumber, true); // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù‡Ø§ØªÙ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ auth.user
          } else if (isVerified && !phoneIsVerified && !isBanned) {
            updateElementText(authStatusDiv, `Ù…Ø±Ø­Ø¨Ø§Ù‹ ${user.email}. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ù„Ù„ÙˆØµÙˆÙ„ Ø§Ù„ÙƒØ§Ù…Ù„.`, 'info');
             // Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† Ù†Ø¹Ø±Ø¶ Ù‚Ø³Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ Ø¥Ø°Ø§ Ø£Ø±Ø¯Ù†Ø§ Ø°Ù„Ùƒ Ø¹Ù†Ø¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ø­Ø³Ø§Ø¨ Ù„Ù… ÙŠØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙ‡ Ø¨Ø¹Ø¯
             // showHideElement(phoneVerificationSection, true); setupRecaptcha();
             // disableElement(mainActionButton, true); // ØªØ¹Ø·ÙŠÙ„ Ø²Ø± ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
             if(gameIconsGridContainer) gameIconsGridContainer.innerHTML = ''; 
             if(settingsUserEmailEl) settingsUserEmailEl.textContent = user.email;
             if(settingsUserPhoneEl) settingsUserPhoneEl.textContent = "ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ";


          } else if (!isBanned) { 
            updateElementText(authStatusDiv, `ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙƒÙ€ ${user.email}. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£ÙˆÙ„Ø§Ù‹.`, 'info');
            if(gameIconsGridContainer) gameIconsGridContainer.innerHTML = ''; 
            if(settingsUserEmailEl) settingsUserEmailEl.textContent = "ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ø£ÙˆÙ„Ø§Ù‹.";
            if(settingsUserPhoneEl) settingsUserPhoneEl.textContent = "Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø¨Ø¹Ø¯";
          }
          navLoginLinkSidebar.textContent = 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬';
          navLoginLinkSidebar.href = "#logout"; 
        } else {
          currentUserIsAdmin = false; 
          isLoginMode = true; 
          updateLoginModeUI(); 
          updateElementText(authStatusDiv, 'ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£Ùˆ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯.', 'info');
          navLoginLinkSidebar.textContent = 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„';
          navLoginLinkSidebar.href = "#login";

          if(gameIconsGridContainer) gameIconsGridContainer.innerHTML = ''; 
          if(settingsUserEmailEl) settingsUserEmailEl.textContent = "ØºÙŠØ± Ù…Ø³Ø¬Ù„ Ø§Ù„Ø¯Ø®ÙˆÙ„";
          if(settingsUserPhoneEl) settingsUserPhoneEl.textContent = "ØºÙŠØ± Ù…Ø³Ø¬Ù„ Ø§Ù„Ø¯Ø®ÙˆÙ„";
          updateElementText(settingsStatusDiv, '', 'info');
          showHideElement(adminButtonSidebar, false); 
          allSections.forEach(s => { 
                if(s.id !== 'login') s.classList.remove('active'); 
          });
        }
        updateSidebarActiveLink(activeSectionId); 
      };

      const updateLoginModeUI = () => { 
        const linkId = 'toggle-auth-mode-link-inner';
        showHideElement(phoneVerificationSection, false); // Ø¥Ø®ÙØ§Ø¡ Ù‚Ø³Ù… Ø§Ù„Ù‡Ø§ØªÙ Ø¹Ù†Ø¯ ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹
        disableElement(mainActionButton, false); // ØªÙ…ÙƒÙŠÙ† Ø²Ø± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ

        if (isLoginMode) {
          loginTitle.textContent = 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„';
          updateButtonText(mainActionButton, 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„'); 
          toggleAuthModeText.innerHTML = `Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ØŸ <a href="#" id="${linkId}">Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨</a>`;
          loginPasswordInput.placeholder = "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±";
          showHideElement(authFormFields, true);
        } else {
          loginTitle.textContent = 'Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯';
          updateButtonText(mainActionButton, 'Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨'); 
          toggleAuthModeText.innerHTML = `Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ Ø¨Ø§Ù„ÙØ¹Ù„ØŸ <a href="#" id="${linkId}">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</a>`;
          loginPasswordInput.placeholder = "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± (6+ Ø­Ø±ÙˆÙ)";
          showHideElement(authFormFields, true); // Ø¥Ø¸Ù‡Ø§Ø± Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ ÙˆØ§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯
        }
        const newToggleLink = document.getElementById(linkId);
        if(newToggleLink) newToggleLink.addEventListener('click', toggleMode);
      };
      
      const toggleMode = (e) => { 
        if(e) e.preventDefault(); 
        isLoginMode = !isLoginMode; 
        updateLoginModeUI(); 
        updateElementText(authStatusDiv, isLoginMode ? 'Ø£Ø¯Ø®Ù„ Ø¨ÙŠØ§Ù†Ø§Øª ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„.' : 'Ø£Ø¯Ø®Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯.', 'info'); 
      };

      const handleAuthAction = () => { 
        const email = loginEmailInput.value.trim(); const password = loginPasswordInput.value;
        if (!email || !password) { updateElementText(authStatusDiv, "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±.", 'error'); return; }
        if (!isLoginMode && password.length < 6) { updateElementText(authStatusDiv, "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø­Ø±ÙˆÙ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„.", 'error'); return; }
        
        updateElementText(authStatusDiv, isLoginMode ? 'Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„...' : 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨...', 'info');
        disableElement(mainActionButton, true);

        if (isLoginMode) { 
            auth.signInWithEmailAndPassword(email, password)
              .then(async (userCredential) => { 
                if (userCredential.user) {
                    const isBanned = await checkIfUserIsBanned(userCredential.user.uid);
                    if (isBanned) {
                        updateElementText(authStatusDiv, "Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø­Ø¸ÙˆØ±.", 'error');
                        auth.signOut();
                    } else if (!userCredential.user.emailVerified) {
                        updateElementText(authStatusDiv, "Ù„Ù‚Ø¯ Ø³Ø¬Ù„Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ØŒ ÙˆÙ„ÙƒÙ† ÙŠØ¬Ø¨ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£ÙˆÙ„Ø§Ù‹.", 'error');
                        auth.signOut(); 
                    } else {
                        const phoneIsVerified = await checkUserPhoneVerified(userCredential.user.uid);
                        if (!phoneIsVerified) {
                             updateElementText(authStatusDiv, `Ù…Ø±Ø­Ø¨Ø§Ù‹ ${userCredential.user.email}. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ù„Ù„ÙˆØµÙˆÙ„ Ø§Ù„ÙƒØ§Ù…Ù„.`, 'info');
                             // Ù„Ø§ ØªØ³Ø¬Ù„ Ø§Ù„Ø®Ø±ÙˆØ¬ØŒ ÙˆÙ„ÙƒÙ† Ù„Ø§ ØªØ³Ù…Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ø§Ù„ÙƒØ§Ù…Ù„ Ø­ØªÙ‰ ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ
                             // Ù‚Ø¯ ØªØ±ØºØ¨ ÙÙŠ ØªÙˆØ¬ÙŠÙ‡Ù‡ Ø¥Ù„Ù‰ ØµÙØ­Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ
                        }
                        loginEmailInput.value = ''; loginPasswordInput.value = '';
                    }
                }
              })
              .catch((error) => {
                let msg = "Ø­Ø¯Ø« Ø®Ø·Ø£. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.";
                if (error.code === 'auth/invalid-api-key' || (error.code === 'auth/internal-error' && error.message.includes("API key not valid"))) {
                    msg = "Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø®Ø¯Ù…Ø© Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©. ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ù…ÙØªØ§Ø­ API ÙÙŠ Ø§Ù„ÙƒÙˆØ¯.";
                } else if (error.code === 'auth/wrong-password' || error.code === 'auth/user-not-found' || error.code === 'auth/invalid-credential') msg = "Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©.";
                else if (error.code === 'auth/invalid-email') msg = "ØµÙŠØºØ© Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ­ÙŠØ­Ø©.";
                console.error("Auth Error Code:",error.code, "Message:", error.message); updateElementText(authStatusDiv, msg, 'error');
              })
              .finally(() => { disableElement(mainActionButton, false); });
        } else { // ÙˆØ¶Ø¹ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯
            auth.createUserWithEmailAndPassword(email, password)
              .then((userCredential) => {
                tempUserCredentialForPhoneAuth = userCredential; //  Ø§Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ù…Ø¤Ù‚ØªÙ‹Ø§
                showHideElement(authFormFields, false); // Ø¥Ø®ÙØ§Ø¡ Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ ÙˆØ§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯
                showHideElement(phoneVerificationSection, true); // Ø¥Ø¸Ù‡Ø§Ø± Ù‚Ø³Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ
                setupRecaptcha(); // ØªÙ‡ÙŠØ¦Ø© reCAPTCHA Ø§Ù„Ø¢Ù† Ù„Ø£Ù†Ù‡ Ù…Ø±Ø¦ÙŠ
                updateElementText(authStatusDiv, 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¨Ø¯Ø¦ÙŠÙ‹Ø§. ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ù„Ù„ØªØ­Ù‚Ù‚.', 'info');
                disableElement(mainActionButton, true); //  ØªØ¹Ø·ÙŠÙ„ Ø²Ø± Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù…Ø¤Ù‚ØªÙ‹Ø§
              })
              .catch((error) => {
                let msg = "Ø­Ø¯Ø« Ø®Ø·Ø£. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.";
                if (error.code === 'auth/invalid-api-key' || (error.code === 'auth/internal-error' && error.message.includes("API key not valid"))) {
                    msg = "Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø®Ø¯Ù…Ø© Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©. ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ù…ÙØªØ§Ø­ API ÙÙŠ Ø§Ù„ÙƒÙˆØ¯.";
                } else if (error.code === 'auth/email-already-in-use') msg = "Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„.";
                else if (error.code === 'auth/weak-password') msg = "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø¶Ø¹ÙŠÙØ© (6 Ø­Ø±ÙˆÙ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„).";
                else if (error.code === 'auth/invalid-email') msg = "ØµÙŠØºØ© Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ­ÙŠØ­Ø©.";
                console.error("Auth Error Code:",error.code, "Message:", error.message); updateElementText(authStatusDiv, msg, 'error');
                disableElement(mainActionButton, false); // Ø¥Ø¹Ø§Ø¯Ø© ØªÙ…ÙƒÙŠÙ† Ø§Ù„Ø²Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø·Ø£
              });
        }
      };
      
      if(btnSendOtp) {
        btnSendOtp.addEventListener('click', () => {
            const phoneNumber = phoneNumberInput.value;
            if (!phoneNumber || !/^\+[1-9]\d{1,14}$/.test(phoneNumber)) { // ØªØ­Ù‚Ù‚ Ø¨Ø³ÙŠØ· Ù…Ù† ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø¯ÙˆÙ„ÙŠ
                updateElementText(phoneAuthStatusDiv, 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙ ØµØ­ÙŠØ­ Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¯ÙˆÙ„ÙŠ (Ù…Ø«Ø§Ù„: +201001234567).', 'error');
                return;
            }
            if (!recaptchaVerifier) {
                updateElementText(phoneAuthStatusDiv, "Ø®Ø·Ø£: reCAPTCHA Ù„Ù… ÙŠØªÙ… ØªÙ‡ÙŠØ¦ØªÙ‡. Ø­Ø§ÙˆÙ„ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.", "error");
                return;
            }

            updateElementText(phoneAuthStatusDiv, 'Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚...', 'info');
            disableElement(btnSendOtp, true);

            auth.signInWithPhoneNumber(phoneNumber, recaptchaVerifier)
                .then((confirmationResult) => {
                    window.confirmationResult = confirmationResult;
                    updateElementText(phoneAuthStatusDiv, 'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ù„Ù‰ Ù‡Ø§ØªÙÙƒ.', 'success');
                    showHideElement(otpInputSection, true);
                    disableElement(btnSendOtp, false); //  Ø£Ø¹Ø¯ ØªÙ…ÙƒÙŠÙ† Ø§Ù„Ø²Ø± Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
                }).catch((error) => {
                    console.error("Error sending OTP:", error);
                    updateElementText(phoneAuthStatusDiv, `ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯: ${error.message}. ØªØ£ÙƒØ¯ Ù…Ù† ØªÙØ¹ÙŠÙ„ Ù…ØµØ§Ø¯Ù‚Ø© Ø§Ù„Ù‡Ø§ØªÙ ÙÙŠ Firebase ÙˆØ£Ù† Ø§Ù„Ù†Ø·Ø§Ù‚ Ù…Ø¶Ø§Ù Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø³Ù…Ø§Ø­.`, 'error');
                    if (window.recaptchaWidgetId) grecaptcha.reset(window.recaptchaWidgetId); // Ø£Ø¹Ø¯ ØªØ¹ÙŠÙŠÙ† reCAPTCHA
                    disableElement(btnSendOtp, false);
                });
        });
      }

      if(btnVerifyOtp) {
        btnVerifyOtp.addEventListener('click', () => {
            const code = otpCodeInput.value;
            if (!code || code.length !== 6) {
                updateElementText(phoneAuthStatusDiv, 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…ÙƒÙˆÙ† Ù…Ù† 6 Ø£Ø±Ù‚Ø§Ù….', 'error');
                return;
            }
            if (!window.confirmationResult) {
                 updateElementText(phoneAuthStatusDiv, 'Ø®Ø·Ø£: Ù„Ù… ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø£ÙˆÙ„Ø§Ù‹.', 'error');
                 return;
            }
            updateElementText(phoneAuthStatusDiv, 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒÙˆØ¯...', 'info');
            disableElement(btnVerifyOtp, true);

            window.confirmationResult.confirm(code).then((result) => {
                const userFromPhoneAuth = result.user; //  Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù…ØµØ§Ø¯Ù‚Ø© Ø§Ù„Ù‡Ø§ØªÙ

                if (tempUserCredentialForPhoneAuth && tempUserCredentialForPhoneAuth.user) {
                    const originalUser = tempUserCredentialForPhoneAuth.user;
                    // Ø±Ø¨Ø· Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„Ù‡Ø§ØªÙ Ø¨Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ØµÙ„ÙŠ Ø§Ù„Ø°ÙŠ ØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡ Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„
                    const phoneCredential = firebase.auth.PhoneAuthProvider.credential(window.confirmationResult.verificationId, code);
                    
                    originalUser.linkWithCredential(phoneCredential).then(() => {
                        updateUserDocument(originalUser, userFromPhoneAuth.phoneNumber, true);
                        originalUser.sendEmailVerification().then(() => {
                            updateElementText(authStatusDiv, 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­ ÙˆØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ! ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ­Ù‚Ù‚ Ø¥Ù„Ù‰ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡Ø§ Ø«Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„.', 'success');
                        }).catch(err => {
                             updateElementText(authStatusDiv, 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙØŒ Ù„ÙƒÙ† ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø±ÙŠØ¯ Ø§Ù„ØªØ­Ù‚Ù‚.', 'error');
                        });
                        auth.signOut(); //  Ø³Ø¬Ù„ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù„ÙŠÙ‚ÙˆÙ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ù† Ø¬Ø¯ÙŠØ¯ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯
                        tempUserCredentialForPhoneAuth = null;
                        updateLoginModeUI(); // Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„ÙˆØ§Ø¬Ù‡Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
                        loginEmailInput.value = ''; loginPasswordInput.value = ''; phoneNumberInput.value = ''; otpCodeInput.value = '';
                    }).catch((error) => {
                        console.error("Error linking phone to email user:", error);
                        // Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„Ø±Ø¨Ø· (Ù…Ø«Ù„Ø§Ù‹ØŒ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ Ù…Ø¹ Ø­Ø³Ø§Ø¨ Ø¢Ø®Ø±)
                        updateElementText(authStatusDiv, `ÙØ´Ù„ Ø±Ø¨Ø· Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ø¨Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¨Ø±ÙŠØ¯: ${error.message}. Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø§Ù„Ø±Ù‚Ù… Ù…Ø³ØªØ®Ø¯Ù…Ø§Ù‹.`, 'error');
                        // Ù‡Ù†Ø§ Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ù„Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø°ÙŠ ØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡ Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±Ø¨Ø· Ø¥Ù„Ø²Ø§Ù…ÙŠÙ‹Ø§
                        originalUser.delete().catch(delErr => console.error("Failed to delete temp user", delErr));
                        updateLoginModeUI();
                    });

                } else {
                    // Ù‡Ø°Ø§ Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ù„Ø§ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­Ø¯Ø« ÙÙŠ Ø§Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ø­Ø§Ù„ÙŠØŒ Ù„ÙƒÙ† ÙƒØ§Ø­ØªÙŠØ§Ø·
                    updateUserDocument(userFromPhoneAuth, userFromPhoneAuth.phoneNumber, true);
                    updateElementText(authStatusDiv, 'ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ø¨Ù†Ø¬Ø§Ø­!', 'success');
                    auth.signOut();
                    updateLoginModeUI();
                }

            }).catch((error) => {
                console.error("Error verifying OTP:", error);
                updateElementText(phoneAuthStatusDiv, `ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒÙˆØ¯: ${error.message}`, 'error');
            }).finally(() => {
                 disableElement(btnVerifyOtp, false);
            });
        });
      }


      updateLoginModeUI(); 
      mainActionButton.addEventListener('click', handleAuthAction);
      
      btnLogout.addEventListener('click', () => { 
        auth.signOut().catch(e => console.error('Logout error', e)); 
        updateElementText(authStatusDiv, 'ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£Ùˆ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯.', 'info');
        window.location.hash = 'login';
        closeSidebar();
      });

      if(btnChangePassword) { 
          btnChangePassword.addEventListener('click', () => {
              const user = auth.currentUser;
              if (user && user.email) {
                  auth.sendPasswordResetEmail(user.email)
                      .then(() => {
                          updateElementText(settingsStatusDiv, 'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø¥Ù„Ù‰ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ.', 'success');
                      })
                      .catch((error) => {
                          console.error("Error sending password reset email:", error);
                          updateElementText(settingsStatusDiv, 'ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', 'error');
                      });
              } else {
                  updateElementText(settingsStatusDiv, 'ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù…Ø³Ø¬Ù„Ø§Ù‹ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±.', 'error');
              }
          });
      }

      const displayUsersForAdmin = () => {
          if (!adminUsersListContainer) return;
          adminUsersListContainer.innerHTML = '<p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...</p>';
          updateElementText(adminStatusDiv, '', 'info');

          db.collection('users').orderBy('createdAt', 'desc').get()
              .then(querySnapshot => {
                  if (querySnapshot.empty) {
                      adminUsersListContainer.innerHTML = '<p>Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ù„Ø¹Ø±Ø¶Ù‡Ù….</p>';
                      return;
                  }
                  let html = '<ul>';
                  querySnapshot.forEach(doc => {
                      const userData = doc.data();
                      const isAdminText = userData.isAdmin ? ' (Ø£Ø¯Ù…Ù†)' : '';
                      const bannedIndicator = userData.isBanned ? '<span class="banned-user-indicator"> (Ù…Ø­Ø¸ÙˆØ±)</span>' : '';
                      const phoneText = userData.phoneNumber ? ` - ${userData.phoneNumber} (${userData.phoneVerified ? 'Ù…ÙØªØ­Ù‚Ù‚' : 'ØºÙŠØ± Ù…ÙØªØ­Ù‚Ù‚'})` : '';
                      const disableBanForSelfOrOtherAdmins = (userData.uid === auth.currentUser.uid || userData.isAdmin) && auth.currentUser.email !== ADMIN_EMAIL ; 

                      html += `<li>
                                 <span>${userData.displayName || userData.email}${isAdminText}${phoneText}${bannedIndicator}</span>
                                 <div class="user-actions">
                                     <button onclick="viewUserDetails('${doc.id}')">ØªÙØ§ØµÙŠÙ„</button>
                                     <button onclick="toggleUserBanStatus('${doc.id}', ${userData.isBanned || false})" 
                                             ${disableBanForSelfOrOtherAdmins ? 'disabled title="Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø¸Ø± Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨"' : ''}>
                                         ${userData.isBanned ? 'Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¸Ø±' : 'Ø­Ø¸Ø±'}
                                     </button>
                                 </div>
                               </li>`;
                  });
                  html += '</ul>';
                  adminUsersListContainer.innerHTML = html;
              })
              .catch(error => {
                  console.error("Error fetching users for admin:", error);
                  adminUsersListContainer.innerHTML = '<p>Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†.</p>';
                  if (error.code === 'permission-denied') {
                      adminUsersListContainer.innerHTML += '<br><b>ØªØ­Ø°ÙŠØ±:</b> Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙˆØµÙˆÙ„. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø§Ù† ÙÙŠ Firestore ØµØ­ÙŠØ­Ø© ÙˆØ£Ù†Ùƒ Ù…Ø³Ø¬Ù„ ÙƒØ£Ø¯Ù…Ù†.';
                  }
                  updateElementText(adminStatusDiv, 'ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†. ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Firestore.', 'error');
              });
      };

      window.viewUserDetails = (userId) => {
          db.collection('users').doc(userId).get().then(doc => {
              if (doc.exists) {
                  const data = doc.data();
                  document.getElementById('details-email').textContent = `Ø§Ù„Ø¨Ø±ÙŠØ¯: ${data.email || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}`;
                  document.getElementById('details-uid').textContent = `UID: ${data.uid || 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}`;
                  document.getElementById('details-created').textContent = `ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡: ${data.createdAt ? new Date(data.createdAt.toDate()).toLocaleString() : 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}`;
                  document.getElementById('details-last-login').textContent = `Ø¢Ø®Ø± ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„: ${data.lastLogin ? new Date(data.lastLogin.toDate()).toLocaleString() : 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}`;
                  document.getElementById('details-phone').textContent = `Ø§Ù„Ù‡Ø§ØªÙ: ${data.phoneNumber || 'Ù„Ù… ÙŠÙØ¶ÙÙ'} (${data.phoneVerified ? 'Ù…ÙØªØ­Ù‚Ù‚' : 'ØºÙŠØ± Ù…ÙØªØ­Ù‚Ù‚'})`;
                  document.getElementById('details-banned-status').textContent = `Ø§Ù„Ø­Ø§Ù„Ø©: ${data.isBanned ? 'Ù…Ø­Ø¸ÙˆØ±' : 'Ù†Ø´Ø·'}${data.isAdmin ? ' (Ø£Ø¯Ù…Ù†)' : ''}`;
                  showHideElement(adminUserDetailsContainer, true);
              } else {
                  updateElementText(adminStatusDiv, 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….', 'error');
              }
          }).catch(err => {
              console.error("Error fetching user details:", err);
              updateElementText(adminStatusDiv, 'Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….', 'error');
          });
      };

      window.toggleUserBanStatus = (userIdToManage, currentBanStatus) => {
          if (auth.currentUser && userIdToManage === auth.currentUser.uid) {
              updateElementText(adminStatusDiv, 'Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø­Ø¸Ø± Ù†ÙØ³Ùƒ.', 'error');
              return;
          }
          db.collection('users').doc(userIdToManage).get().then(doc => {
            if (doc.exists && doc.data().isAdmin && auth.currentUser && auth.currentUser.email !== ADMIN_EMAIL) { 
                updateElementText(adminStatusDiv, 'Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø­Ø¸Ø± Ø­Ø³Ø§Ø¨ Ø£Ø¯Ù…Ù† Ø¢Ø®Ø±.', 'error');
                return;
            }

            const newBanStatus = !currentBanStatus;
            db.collection('users').doc(userIdToManage).update({
                isBanned: newBanStatus
            })
            .then(() => {
                updateElementText(adminStatusDiv, `ØªÙ… ${newBanStatus ? 'Ø­Ø¸Ø±' : 'Ø¥Ù„ØºØ§Ø¡ Ø­Ø¸Ø±'} Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­.`, 'success');
                displayUsersForAdmin(); 
                showHideElement(adminUserDetailsContainer, false); 
            })
            .catch(error => {
                console.error("Error updating ban status:", error);
                updateElementText(adminStatusDiv, 'ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¸Ø±.', 'error');
            });
          }).catch(err => {
             console.error("Error checking if target user is admin:", err);
             updateElementText(adminStatusDiv, 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù‡Ø¯Ù.', 'error');
          });
      };


      window.showAdminArea = (event) => { 
          event.preventDefault();
          if (currentUserIsAdmin) { 
              window.location.hash = "admin-area";
              displayUsersForAdmin(); 
          } else {
              alert("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ù…Ù† Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù†Ø·Ù‚Ø©.");
              window.location.hash = "game-launcher"; 
          }
          closeSidebar();
      };

      const populateGameLauncher = () => { 
        if (!gameIconsGridContainer) return;
        gameIconsGridContainer.innerHTML = ''; 
        gameNavLinksData.forEach(game => {
            const card = document.createElement('div');
            card.className = 'game-icon-card';
            card.dataset.targetId = game.id;
            const icon = document.createElement('i');
            icon.className = `bx ${game.icon}`;
            const nameSpan = document.createElement('span');
            nameSpan.textContent = game.text;
            card.appendChild(icon);
            card.appendChild(nameSpan);
            card.addEventListener('click', async (e) => { 
                const targetId = e.currentTarget.dataset.targetId;
                const currentUser = auth.currentUser;
                if (currentUser && currentUser.emailVerified) {
                    const isBanned = await checkIfUserIsBanned(currentUser.uid);
                    const phoneIsVerified = await checkUserPhoneVerified(currentUser.uid);
                    if (isBanned) {
                        updateElementText(authStatusDiv, "Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±. Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ù„Ø¹Ø¨ Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨.", "error");
                        auth.signOut(); 
                        window.location.hash = 'login';
                    } else if (!phoneIsVerified) {
                        updateElementText(authStatusDiv, "ÙŠØ¬Ø¨ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£ÙˆÙ„Ø§Ù‹ Ù„Ù„Ø¹Ø¨.", "error");
                        window.location.hash = 'login'; // Ø£Ùˆ 'settings' Ù„ØªÙˆØ¬ÙŠÙ‡Ù‡ Ù„Ù„ØªØ­Ù‚Ù‚
                    } else {
                        playSound('snd-click');
                        window.location.hash = targetId;
                    }
                } else if (currentUser && !currentUser.emailVerified) {
                     updateElementText(authStatusDiv, "ÙŠØ¬Ø¨ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£ÙˆÙ„Ø§Ù‹ Ù„Ù„Ø¹Ø¨.", "error");
                    window.location.hash = 'login';
                } else {
                    updateElementText(authStatusDiv, "ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù„Ø¹Ø¨.", "error");
                    window.location.hash = 'login';
                }
            });
            gameIconsGridContainer.appendChild(card);
        });
      };
      
      const updateSidebarActiveLink = (activeSectionId) => { 
        const links = sidebar.querySelectorAll('a');
        links.forEach(a => {
            if (a) a.classList.remove('active-nav-link');
            if (a && a.getAttribute('href') === `#${activeSectionId}`) {
                a.classList.add('active-nav-link');
            }
        });
        if (activeSectionId === 'login' && auth.currentUser) {
        } else if (activeSectionId === 'login' && !auth.currentUser) {
            if(navLoginLinkSidebar) navLoginLinkSidebar.classList.add('active-nav-link');
        }
      };

      const showSectionByHash = async () => { 
        let hash = window.location.hash.slice(1);
        const currentUser = auth.currentUser;
        
        let isBanned = false;
        let emailIsVerified = false;
        let phoneIsVerified = false;

        if (currentUser) {
            emailIsVerified = currentUser.emailVerified;
            isBanned = await checkIfUserIsBanned(currentUser.uid);
            if (isBanned) {
                emailIsVerified = false; 
                phoneIsVerified = false;
                if (hash !== 'login') {
                     window.location.hash = 'login'; 
                     return; 
                }
            } else if (emailIsVerified) {
                 phoneIsVerified = await checkUserPhoneVerified(currentUser.uid);
            }
        }

        if (!hash) { 
            if (emailIsVerified && phoneIsVerified) { 
                hash = 'game-launcher'; 
            } else {
                hash = 'login';
            }
            if (window.location.hash.slice(1) !== hash) {
                window.location.hash = hash; 
                return; 
            }
        }
        
        let targetIdToShow = 'login'; 
        if (emailIsVerified && phoneIsVerified) { 
            if (hash === 'game-launcher' || gameNavLinksData.some(game => game.id === hash) || hash === 'settings') {
                targetIdToShow = hash;
            } else if (hash === 'admin-area' && currentUserIsAdmin) { 
                targetIdToShow = hash;
                displayUsersForAdmin(); 
            } else if (hash === 'login'){ 
                 targetIdToShow = 'game-launcher'; 
                 if (window.location.hash !== '#game-launcher') window.location.hash = 'game-launcher';
            } else { 
                targetIdToShow = 'game-launcher';
                if (window.location.hash !== '#game-launcher') window.location.hash = 'game-launcher';
            }
        } else { 
            if (hash !== 'login' && hash !== '') { 
                 if (window.location.hash !== '#login') window.location.hash = 'login';
                 targetIdToShow = 'login';
            } else { 
                targetIdToShow = 'login';
            }
        }
        
        allSections.forEach(s => {
            if (s.id === targetIdToShow) {
                s.classList.add('active');
            } else {
                s.classList.remove('active');
            }
        });
        updateSidebarActiveLink(targetIdToShow);
        if (targetIdToShow === 'settings' && settingsStatusDiv) updateElementText(settingsStatusDiv, '', 'info'); 
        if (targetIdToShow === 'admin-area' && adminStatusDiv) updateElementText(adminStatusDiv, 'Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø£ÙŠÙ‡Ø§ Ø§Ù„Ø£Ø¯Ù…Ù†.', 'info');
      };
      
      auth.onAuthStateChanged(async user => { 
        await updateAuthUI(!!user, user, user ? user.emailVerified : false); 
        
        if(user && user.emailVerified) {
            const userDoc = await db.collection('users').doc(user.uid).get().catch(() => null);
            currentUserIsAdmin = userDoc && userDoc.exists && userDoc.data().isAdmin === true;
            const phoneIsVerified = userDoc && userDoc.exists && userDoc.data().phoneVerified === true;
            showHideElement(adminButtonSidebar, currentUserIsAdmin && user.emailVerified && phoneIsVerified);
        } else {
            currentUserIsAdmin = false;
            showHideElement(adminButtonSidebar, false);
        }
        showSectionByHash(); 
      });

      const handleSidebarLinkClick = (e) => {
          e.preventDefault(); 
          const targetHash = e.currentTarget.getAttribute('href');
          if (targetHash === '#logout') { 
            auth.signOut().then(() => {
                 currentUserIsAdmin = false; 
                 window.location.hash = 'login'; 
            }).catch(err => console.error('Logout error', err));
          } else {
            window.location.hash = targetHash;
          }
          closeSidebar();
      };

      navLoginLinkSidebar.addEventListener('click', handleSidebarLinkClick);
      if (navGamesLauncherLinkSidebar) navGamesLauncherLinkSidebar.addEventListener('click', handleSidebarLinkClick);
      if (navSettingsLinkSidebar) navSettingsLinkSidebar.addEventListener('click', handleSidebarLinkClick);
      
      window.addEventListener('hashchange', showSectionByHash);

      function openSidebar() { if(sidebar) sidebar.classList.add('open'); }
      function closeSidebar() { if(sidebar) sidebar.classList.remove('open'); }
      if(sidebarToggleButton) sidebarToggleButton.addEventListener('click', openSidebar);
      if(sidebarCloseButton) sidebarCloseButton.addEventListener('click', closeSidebar);
      document.addEventListener('click', function(event) {
        if (sidebar && sidebar.classList.contains('open') && 
            !sidebar.contains(event.target) && 
            !sidebarToggleButton.contains(event.target)) {
            closeSidebar();
        }
      });

      const initXOGame = () => { 
          const section = document.querySelector('#xo');
          if (!section) return;
          const boardElement = section.querySelector('.board');
          const statusElement = section.querySelector('.status');
          const restartButton = section.querySelector('#xo-restart');
          const exitGameButton = section.querySelector('#xo-exit-game');
          const pvpButton = section.querySelector('#xo-pvp');
          const pvcHardButton = section.querySelector('#xo-pvc-hard'); 
          const canvas = section.querySelector('#xo-winning-line-canvas');
          const ctx = canvas.getContext('2d');
          const boardContainer = section.querySelector('.xo-board-container');
          const optionsDiv = section.querySelector('.xo-options');

          let boardState = Array(9).fill('');
          let currentPlayer = 'âŒ';
          let gameActive = false;
          let gameMode = null; 
          const playerSymbol = 'âŒ';
          const computerSymbol = 'â­•';

          const winningPatterns = [
              [0, 1, 2], [3, 4, 5], [6, 7, 8], 
              [0, 3, 6], [1, 4, 7], [2, 5, 8], 
              [0, 4, 8], [2, 4, 6]             
          ];

          const resizeCanvas = () => {
              if(!boardContainer || !canvas) return;
              canvas.width = boardContainer.offsetWidth;
              canvas.height = boardContainer.offsetHeight;
          };
          
          const resetGame = () => {
              gameActive = false; gameMode = null; boardState.fill(''); currentPlayer = playerSymbol;
              if (boardElement) Array.from(boardElement.children).forEach(cell => cell.textContent = '');
              if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
              updateElementText(statusElement, 'Ø§Ø®ØªØ± Ù†Ù…Ø· Ø§Ù„Ù„Ø¹Ø¨Ø©');
              showHideElement(restartButton, false);
              showHideElement(exitGameButton, false);
              showHideElement(optionsDiv, true);
              disableBoardInteraction(false); 
          };

          const drawWinningLine = (combination) => {
              if (!combination || combination.length < 3 || !ctx) return;
              resizeCanvas(); 
              ctx.clearRect(0, 0, canvas.width, canvas.height); 
              ctx.save(); ctx.translate(0.5, 0.5); 
              ctx.beginPath(); ctx.lineWidth = 10; ctx.strokeStyle = 'rgba(220, 53, 69, 0.9)'; ctx.lineCap = 'round';
              const cellSize = 100; const gap = 8;      
              const getCellCenter = (index) => {
                  const row = Math.floor(index / 3); const col = index % 3;
                  const x = col * (cellSize + gap) + cellSize / 2; const y = row * (cellSize + gap) + cellSize / 2;
                  return { x, y };
              };
              const startCell = getCellCenter(combination[0]); const endCell = getCellCenter(combination[2]);
              ctx.moveTo(startCell.x, startCell.y); ctx.lineTo(endCell.x, endCell.y); ctx.stroke();
              ctx.restore(); 
          };
          
          const checkWin = () => { 
              for (const pattern of winningPatterns) {
                  const [a, b, c] = pattern;
                  if (boardState[a] && boardState[a] === boardState[b] && boardState[a] === boardState[c]) {
                      return { winner: boardState[a], combination: pattern };
                  }
              }
              if (!boardState.includes('')) return { winner: 'tie', combination: null }; 
              return null; 
          };
          
          const checkWinWithBoard = (boardToCheck) => {
            for (const pattern of winningPatterns) {
                const [a, b, c] = pattern;
                if (boardToCheck[a] && boardToCheck[a] === boardToCheck[b] && boardToCheck[a] === boardToCheck[c]) {
                    return { winner: boardToCheck[a], combination: pattern };
                }
            }
            if (!boardToCheck.includes('')) return { winner: 'tie', combination: null };
            return null;
          };

          const handleClick = async (index) => { 
              const user = auth.currentUser;
              if (!gameActive || boardState[index] || !user || !user.emailVerified) return;

              const isBanned = await checkIfUserIsBanned(user.uid);
              const phoneIsVerified = await checkUserPhoneVerified(user.uid);
              if (isBanned || !phoneIsVerified) {
                  updateElementText(statusElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error');
                  if(isBanned) auth.signOut(); 
                  window.location.hash = 'login'; return;
              }

              boardState[index] = currentPlayer;
              boardElement.children[index].textContent = currentPlayer;
              playSound('snd-click');
              const winResult = checkWin();
              if (winResult) {
                  gameActive = false;
                  if (winResult.winner === 'tie') { updateElementText(statusElement, 'ØªØ¹Ø§Ø¯Ù„!'); playSound('snd-lose');
                  } else { updateElementText(statusElement, `ÙØ§Ø² ${winResult.winner}!`); playSound('snd-win'); drawWinningLine(winResult.combination); }
                  showHideElement(restartButton, true); showHideElement(exitGameButton, true);
                  return;
              }
              currentPlayer = (currentPlayer === playerSymbol) ? computerSymbol : playerSymbol;
              updateElementText(statusElement, `Ø§Ù„Ø¯ÙˆØ±: ${currentPlayer}`);
              if (gameMode === 'pvc-hard' && gameActive && currentPlayer === computerSymbol) {
                  disableBoardInteraction(true);
                  setTimeout(() => {
                      const moveIndex = computerMoveHard();
                      if (moveIndex !== -1 && boardState[moveIndex] === '') handleClick(moveIndex); 
                      disableBoardInteraction(false);
                  }, 300 + Math.random() * 200);
              } else { disableBoardInteraction(false); }
          };
          
          const disableBoardInteraction = (disable) => {
            if (boardElement) Array.from(boardElement.children).forEach(cell => cell.style.pointerEvents = disable ? 'none' : 'auto');
          };

          const computerMoveHard = () => { 
            if (!gameActive) return -1;
            const findStrategicMove = (player, currentBoardState) => {
                for (let i = 0; i < currentBoardState.length; i++) {
                    if (currentBoardState[i] === '') {
                        let tempBoard = [...currentBoardState]; tempBoard[i] = player; 
                        const winCheck = checkWinWithBoard(tempBoard);
                        if (winCheck && winCheck.winner === player) return i; 
                    }
                }
                return -1; 
            };
            let move = findStrategicMove(computerSymbol, boardState); if (move !== -1) return move;
            move = findStrategicMove(playerSymbol, boardState); if (move !== -1) return move;
            if (boardState[4] === '') return 4;
            const corners = [0, 2, 6, 8]; const emptyCorners = corners.filter(corner => boardState[corner] === '');
            if (emptyCorners.length > 0) return emptyCorners[Math.floor(Math.random() * emptyCorners.length)];
            const sides = [1, 3, 5, 7]; const emptySides = sides.filter(side => boardState[side] === '');
            if (emptySides.length > 0) return emptySides[Math.floor(Math.random() * emptySides.length)];
            for (let i = 0; i < boardState.length; i++) { if (boardState[i] === '') return i;}
            return -1; 
          };

          const startGameMode = async (mode) => { 
              const user = auth.currentUser;
              if (!user || !user.emailVerified) {
                  updateElementText(statusElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return;
              }
              const isBanned = await checkIfUserIsBanned(user.uid);
              const phoneIsVerified = await checkUserPhoneVerified(user.uid);
              if (isBanned || !phoneIsVerified) {
                  updateElementText(statusElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error');
                  if(isBanned) auth.signOut();
                  window.location.hash = 'login'; return;
              }

              gameMode = mode; gameActive = true; boardState.fill(''); currentPlayer = playerSymbol; 
              if (boardElement) Array.from(boardElement.children).forEach(cell => cell.textContent = '');
              if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); 
              updateElementText(statusElement, `Ø§Ù„Ø¯ÙˆØ±: ${currentPlayer}`);
              showHideElement(optionsDiv, false); 
              showHideElement(restartButton, true); showHideElement(exitGameButton, true);
              disableBoardInteraction(false); playSound('snd-click');
          };
          
          if (boardElement) {
             boardElement.innerHTML = Array(9).fill().map((_, i) => `<div class="cell" data-index="${i}"></div>`).join('');
             Array.from(boardElement.children).forEach((cell, i) => cell.addEventListener('click', () => handleClick(i)));
          }
          
          if(pvpButton) pvpButton.addEventListener('click', () => startGameMode('pvp'));
          if(pvcHardButton) pvcHardButton.addEventListener('click', () => startGameMode('pvc-hard')); 
          if(restartButton) restartButton.addEventListener('click', () => { playSound('snd-click'); startGameMode(gameMode); }); 
          if(exitGameButton) exitGameButton.addEventListener('click', () => {
              playSound('snd-click');
              resetGame();
              if (auth.currentUser && auth.currentUser.emailVerified) window.location.hash = 'game-launcher';
          });
          
          window.addEventListener('resize', resizeCanvas);
          const observer = new MutationObserver((mutationsList) => {
            for(const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (section.classList.contains('active')) {
                        resizeCanvas(); 
                        if (!gameActive) resetGame(); 
                    } else {
                        if (gameActive) resetGame(); 
                    }
                }
            }
          });
          if(section) observer.observe(section, { attributes: true });
          resetGame(); 
      };
      
      const initMemoryGame = () => { 
        const section = document.querySelector('#memory'); if (!section) return;
        const cardsContainer = section.querySelector('.cards');
        const statusElement = section.querySelector('.status');
        const restartButton = section.querySelector('#memory-restart');
        const exitGameButton = section.querySelector('#memory-exit-game');
        const pvpButtonMemory = section.querySelector('#memory-pvp');
        const soloButtonMemory = section.querySelector('#memory-solo');
        const optionsDivMemory = section.querySelector('.memory-options');
        const scoresDivMemory = section.querySelector('.memory-scores');
        const player1ScoreEl = section.querySelector('#memory-player1-score');
        const player2ScoreEl = section.querySelector('#memory-player2-score');
        const player2Separator = section.querySelector('#memory-player2-separator');
        const playerNamesInputDiv = section.querySelector('.memory-player-names-input');
        const player1NameInput = section.querySelector('#memory-player1-name');
        const player2NameInput = section.querySelector('#memory-player2-name');
        const startPvpNamedButton = section.querySelector('#memory-start-pvp-named');

        const cardValues = ['ğŸ§ ', 'ğŸ®', 'ğŸ¯', 'ğŸ²', 'ğŸ’¡', 'ğŸ’»', 'ğŸŒŸ', 'ğŸš€'];
        let gameCards = []; let flippedCards = []; let canFlip = true;
        let gameActiveMemory = false; let gameModeMemory = null; 
        let currentPlayerMemory = null; 
        let playerNames = { player1: "Ø§Ù„Ù„Ø§Ø¹Ø¨ 1", player2: "Ø§Ù„Ù„Ø§Ø¹Ø¨ 2" };
        let scoresMemory = { player1: 0, player2: 0 };
        const FLIP_BACK_DELAY = 1800; 

        function shuffle(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
        
        const resetMemoryGame = () => {
            gameActiveMemory = false; gameModeMemory = null; 
            if(cardsContainer) cardsContainer.innerHTML = '';
            showHideElement(optionsDivMemory, true); showHideElement(playerNamesInputDiv, false);
            showHideElement(cardsContainer, false); showHideElement(scoresDivMemory, false);
            showHideElement(restartButton, false); showHideElement(exitGameButton, false);
            updateElementText(statusElement, 'Ø§Ø®ØªØ± Ù†Ù…Ø· Ø§Ù„Ù„Ø¹Ø¨Ø©');
            canFlip = true; 
        };

        function updateScoresDisplay() { if (gameModeMemory === 'pvp-memory') { player1ScoreEl.textContent = `${playerNames.player1}: ${scoresMemory.player1}`; player2ScoreEl.textContent = `${playerNames.player2}: ${scoresMemory.player2}`; showHideElement(player2ScoreEl, true); showHideElement(player2Separator, true); } else if (gameModeMemory === 'solo-memory') { player1ScoreEl.textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${scoresMemory.player1}`; showHideElement(player2ScoreEl, false); showHideElement(player2Separator, false); } }
        function updateStatus() { if (!gameActiveMemory) { updateElementText(statusElement, "Ø§Ø®ØªØ± Ù†Ù…Ø· Ø§Ù„Ù„Ø¹Ø¨Ø©"); return; } let turnText = ""; if (gameModeMemory === 'pvp-memory') { turnText = currentPlayerMemory === 'player1' ? `Ø¯ÙˆØ± ${playerNames.player1}` : `Ø¯ÙˆØ± ${playerNames.player2}`; } else if (gameModeMemory === 'solo-memory') { turnText = "Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªØ·Ø§Ø¨Ù‚Ø§Øª!"; } updateElementText(statusElement, turnText); }
        function preparePvpNameInputs() { showHideElement(optionsDivMemory, false); showHideElement(playerNamesInputDiv, true); player1NameInput.value = ''; player2NameInput.value = ''; showHideElement(restartButton, false); showHideElement(exitGameButton, false); }
        
        async function startGameMemory(mode, pvpSetupDone = false) { 
            const user = auth.currentUser;
            if (!user || !user.emailVerified) { updateElementText(statusElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return; }
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) {
                updateElementText(statusElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error');
                if(isBanned) auth.signOut();
                window.location.hash = 'login'; return;
            }

            if (mode === 'pvp-memory' && !pvpSetupDone) { preparePvpNameInputs(); return; }
            if (mode === 'pvp-memory' && pvpSetupDone) {
                 playerNames.player1 = player1NameInput.value.trim() || "Ø§Ù„Ù„Ø§Ø¹Ø¨ 1";
                 playerNames.player2 = player2NameInput.value.trim() || "Ø§Ù„Ù„Ø§Ø¹Ø¨ 2";
            }
            gameModeMemory = mode; gameActiveMemory = true; canFlip = true; flippedCards = [];
            scoresMemory = { player1: 0, player2: 0 }; currentPlayerMemory = 'player1';
            showHideElement(optionsDivMemory, false); showHideElement(playerNamesInputDiv, false);
            showHideElement(scoresDivMemory, true); showHideElement(cardsContainer, true, 'grid');
            if(cardsContainer) cardsContainer.classList.remove('disabled'); 
            showHideElement(restartButton, true); showHideElement(exitGameButton, true);
            updateScoresDisplay(); createMemoryBoard(); updateStatus(); playSound('snd-click');
        }
        function createMemoryBoard() { if(!cardsContainer) return; cardsContainer.innerHTML = ''; let items = shuffle([...cardValues, ...cardValues]); gameCards = []; items.forEach((value, index) => { const card = document.createElement('div'); card.classList.add('card'); card.dataset.value = value; card.dataset.id = index;  const cardFaceFront = document.createElement('div'); cardFaceFront.classList.add('card-face', 'card-front'); const cardFaceBack = document.createElement('div'); cardFaceBack.classList.add('card-face', 'card-back'); cardFaceBack.textContent = value; card.appendChild(cardFaceFront); card.appendChild(cardFaceBack); card.addEventListener('click', () => flipCardMemory(card)); cardsContainer.appendChild(card); gameCards.push(card); }); }
        
        async function flipCardMemory(card) { 
            const user = auth.currentUser;
            if (!user || !user.emailVerified) { updateElementText(statusElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return; }
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) {
                updateElementText(statusElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error');
                if(isBanned) auth.signOut();
                window.location.hash = 'login'; return;
            }
            if (!gameActiveMemory || !canFlip || card.classList.contains('flipped') || card.classList.contains('matched')) return; 
            card.classList.add('flipped'); flippedCards.push(card); playSound('snd-click'); if (flippedCards.length === 2) { canFlip = false; checkForMatchMemory(); } 
        }
        function checkForMatchMemory() { const [card1, card2] = flippedCards; const isMatch = card1.dataset.value === card2.dataset.value; if (isMatch) { card1.classList.add('matched'); card2.classList.add('matched'); if (gameModeMemory === 'pvp-memory') { if (currentPlayerMemory === 'player1') scoresMemory.player1++; else if (currentPlayerMemory === 'player2') scoresMemory.player2++; } else { scoresMemory.player1++; } updateScoresDisplay(); playSound('snd-win'); const totalPairs = cardValues.length; const matchedPairsCount = scoresMemory.player1 + (gameModeMemory === 'pvp-memory' ? scoresMemory.player2 : 0); if (matchedPairsCount === totalPairs) { gameActiveMemory = false; canFlip = false; let winnerMsg = "Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! "; if (gameModeMemory === 'pvp-memory') { if (scoresMemory.player1 > scoresMemory.player2) winnerMsg += `ÙØ§Ø² ${playerNames.player1}!`; else if (scoresMemory.player2 > scoresMemory.player1) winnerMsg += `ÙØ§Ø² ${playerNames.player2}!`; else winnerMsg += "ØªØ¹Ø§Ø¯Ù„!"; } else { winnerMsg += `Ø£Ø­Ø³Ù†Øª!`; } updateElementText(statusElement, winnerMsg, 'success'); showHideElement(restartButton, true); showHideElement(exitGameButton, true); } else { flippedCards = []; canFlip = true;  if (gameModeMemory === 'pvp-memory') updateStatus();  } } else { playSound('snd-lose'); setTimeout(() => { card1.classList.remove('flipped'); card2.classList.remove('flipped'); flippedCards = []; if (gameActiveMemory) { if (gameModeMemory === 'pvp-memory') switchPlayerMemory(); else canFlip = true;  } }, FLIP_BACK_DELAY);  } }
        function switchPlayerMemory() {  if (!gameActiveMemory || gameModeMemory !== 'pvp-memory') return; currentPlayerMemory = currentPlayerMemory === 'player1' ? 'player2' : 'player1'; updateStatus(); canFlip = true;  }
        
        if(pvpButtonMemory) pvpButtonMemory.addEventListener('click', () => startGameMemory('pvp-memory', false));
        if(startPvpNamedButton) startPvpNamedButton.addEventListener('click', () => startGameMemory('pvp-memory', true));
        if(soloButtonMemory) soloButtonMemory.addEventListener('click', () => startGameMemory('solo-memory'));
        if(restartButton) restartButton.addEventListener('click', () => { playSound('snd-click'); startGameMemory(gameModeMemory, true); }); 
        if(exitGameButton) exitGameButton.addEventListener('click', () => {
            playSound('snd-click');
            resetMemoryGame();
            if (auth.currentUser && auth.currentUser.emailVerified) window.location.hash = 'game-launcher';
        });

        const observer = new MutationObserver((mutationsList) => {
            for(const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (section.classList.contains('active')) {
                        if (!gameActiveMemory) resetMemoryGame(); 
                    } else {
                        if (gameActiveMemory) resetMemoryGame(); 
                    }
                }
            }
        });
        if(section) observer.observe(section, { attributes: true });
        resetMemoryGame();
      };
      
      const initRPSGame = () => { 
        const section = document.querySelector('#rps'); if(!section) return;
        const resultElement = section.querySelector('.result');
        const choiceButtons = section.querySelectorAll('.gamebox button');
        const exitGameButton = section.querySelector('#rps-exit-game');
        const options = ['ğŸ§±', 'ğŸ“„', 'âœ‚ï¸']; 

        const resetRPSGame = () => {
            if(resultElement) updateElementText(resultElement, 'Ø§Ø®ØªØ± Ù„Ø¨Ø¯Ø¡!');
        };

        choiceButtons.forEach(button => button.addEventListener('click', async () => { 
          const user = auth.currentUser;
          if(!user||!user.emailVerified) {updateElementText(resultElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.','info'); return;}
          const isBanned = await checkIfUserIsBanned(user.uid);
          const phoneIsVerified = await checkUserPhoneVerified(user.uid);
          if (isBanned || !phoneIsVerified) {
              updateElementText(resultElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error');
              if(isBanned) auth.signOut();
              window.location.hash = 'login'; return;
          }
          const playerChoice = button.dataset.choice;
          const computerChoice = options[Math.floor(Math.random() * options.length)];
          let message = 'ØªØ¹Ø§Ø¯Ù„';
          if ( (playerChoice === 'ğŸ§±' && computerChoice === 'âœ‚ï¸') || (playerChoice === 'ğŸ“„' && computerChoice === 'ğŸ§±') || (playerChoice === 'âœ‚ï¸' && computerChoice === 'ğŸ“„') ) { message = 'ÙØ²Øª'; }
          else if (playerChoice !== computerChoice) { message = 'Ø®Ø³Ø±Øª'; }
          updateElementText(resultElement, `${message}! Ø£Ù†Øª: ${playerChoice} Ø§Ù„ÙƒÙˆÙ…Ø¨ÙŠÙˆØªØ±: ${computerChoice}`);
          playSound(message === 'ÙØ²Øª' ? 'snd-win' : message === 'Ø®Ø³Ø±Øª' ? 'snd-lose' : 'snd-click');
        }));

        if(exitGameButton) exitGameButton.addEventListener('click', () => {
            playSound('snd-click');
            resetRPSGame();
            if (auth.currentUser && auth.currentUser.emailVerified) window.location.hash = 'game-launcher';
        });

        const observerRPS = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (section.classList.contains('active')) {
                         resetRPSGame(); 
                    } 
                }
            }
        });
        if (section) observerRPS.observe(section, { attributes: true });
        resetRPSGame(); 
      };

      const initClickTargetGame = () => { 
        const section = document.querySelector('#click'); if (!section) return;
        const startButton = section.querySelector('#click-start');
        const exitGameButton = section.querySelector('#click-exit-game');
        const targetArea = section.querySelector('#click-target-area');
        const statusElement = section.querySelector('.status');
        let score = 0; let gameTimerId; let targetElement; let gameActiveClick = false;
        const gameDuration = 15000; 

        const resetClickTargetGame = () => {
            clearTimeout(gameTimerId);
            if (targetElement) targetElement.remove();
            targetElement = null;
            score = 0;
            updateElementText(statusElement, 'Ø§Ø¶ØºØ· "Ø§Ø¨Ø¯Ø£"');
            showHideElement(startButton, true);
            showHideElement(exitGameButton, false);
            showHideElement(targetArea, false);
            disableElement(startButton, false);
            gameActiveClick = false;
        };

        const spawnTarget = () => { if(!targetArea) return; if (targetElement) targetElement.remove(); targetElement = document.createElement('div'); targetElement.id = 'clickable-target'; targetElement.textContent = 'ğŸ¯'; const areaRect = targetArea.getBoundingClientRect(); const targetSize = 50; if (areaRect.height <= targetSize || areaRect.width <= targetSize) { gameActiveClick = false; resetClickTargetGame(); return; } targetElement.style.top = Math.random() * (areaRect.height - targetSize) + 'px'; targetElement.style.left = Math.random() * (areaRect.width - targetSize) + 'px'; targetElement.onclick = async () => { 
            const user = auth.currentUser; 
            if(!user||!user.emailVerified) {updateElementText(statusElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.','info'); return;}
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(statusElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            if(!gameActiveClick) return; score++; updateElementText(statusElement, `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`); playSound('snd-click'); spawnTarget(); }; targetArea.appendChild(targetElement); };
        
        const startGame = async () => { 
            const user = auth.currentUser;
            if (!user||!user.emailVerified) {updateElementText(statusElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.','info'); return;}
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(statusElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            
            gameActiveClick = true; score = 0;
            updateElementText(statusElement, 'Ø§Ù„Ù†Ù‚Ø§Ø·: 0');
            showHideElement(startButton, false); showHideElement(exitGameButton, true);
            showHideElement(targetArea, true); disableElement(startButton, true);
            setTimeout(spawnTarget, 50); 
            clearTimeout(gameTimerId);
            gameTimerId = setTimeout(() => {
                gameActiveClick = false;
                if (targetElement) targetElement.remove(); targetElement = null;
                updateElementText(statusElement, `Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! Ù†Ù‚Ø§Ø·Ùƒ: ${score}`);
                playSound(score > 5 ? 'snd-win' : 'snd-lose');
                showHideElement(startButton, true); showHideElement(exitGameButton, false);
                showHideElement(targetArea, false); disableElement(startButton, false);
            }, gameDuration);
        };
        if(startButton) startButton.addEventListener('click', startGame);
        if(exitGameButton) exitGameButton.addEventListener('click', () => {
            playSound('snd-click');
            resetClickTargetGame();
            if (auth.currentUser && auth.currentUser.emailVerified) window.location.hash = 'game-launcher';
        });
        
        const observerClick = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (section.classList.contains('active')) {
                        if (!gameActiveClick) resetClickTargetGame();
                    } else {
                        if (gameActiveClick) resetClickTargetGame();
                    }
                }
            }
        });
        if (section) observerClick.observe(section, { attributes: true });
        resetClickTargetGame();
      };

      const initReactionTestGame = () => { 
        const section = document.querySelector('#react'); if (!section) return;
        const reactBox = section.querySelector('#react-box');
        const exitGameButton = section.querySelector('#react-exit-game');
        let startTime, timeoutId, waitingForClick = false, gameActiveReact = false;

        const resetReactionTestGame = () => {
            clearTimeout(timeoutId);
            waitingForClick = false; gameActiveReact = false;
            updateElementText(reactBox, 'Ø§Ø¶ØºØ· Ù„Ù„Ø¨Ø¯Ø¡');
            if(reactBox) reactBox.classList.remove('waiting', 'ready');
        };

        const startGame = async () => { 
            if(!reactBox) return;
            const user = auth.currentUser;
            if (!user||!user.emailVerified) {updateElementText(reactBox, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.','info'); if(reactBox) reactBox.classList.remove('waiting', 'ready'); return;}
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(reactBox, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            
            if (waitingForClick) { 
                gameActiveReact = false; 
                if (reactBox.classList.contains('ready')) { 
                    const reactionTime = Date.now() - startTime;
                    updateElementText(reactBox, `ÙˆÙ‚ØªÙƒ: ${reactionTime} Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©. Ø§Ø¶ØºØ· Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯.`);
                    playSound('snd-win');
                } else { 
                    updateElementText(reactBox, 'Ù…Ø¨ÙƒØ± Ø¬Ø¯Ø§Ù‹! Ø§Ø¶ØºØ· Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯.');
                    playSound('snd-lose');
                }
                waitingForClick = false; clearTimeout(timeoutId);
                if(reactBox) reactBox.classList.remove('waiting', 'ready');
                return;
            }
            
            updateElementText(reactBox, 'Ø§Ù†ØªØ¸Ø± Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø®Ø¶Ø±...', 'waiting');
            waitingForClick = true; gameActiveReact = true; 
            const randomDelay = Math.random() * 3000 + 1000; 
            timeoutId = setTimeout(() => {
                if (waitingForClick) { 
                    updateElementText(reactBox, 'Ø§Ø¶ØºØ· Ø§Ù„Ø¢Ù†!', 'ready');
                    startTime = Date.now();
                }
            }, randomDelay);
        };
        if(reactBox) reactBox.addEventListener('click', startGame);
        if(exitGameButton) exitGameButton.addEventListener('click', () => {
            playSound('snd-click');
            resetReactionTestGame();
            if (auth.currentUser && auth.currentUser.emailVerified) window.location.hash = 'game-launcher';
        });

        const observerReact = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (section.classList.contains('active')) {
                        if (!gameActiveReact && !waitingForClick) resetReactionTestGame();
                    } else {
                        if (gameActiveReact || waitingForClick) resetReactionTestGame();
                    }
                }
            }
        });
        if (section) observerReact.observe(section, { attributes: true });
        resetReactionTestGame();
      };

      const initDiceRollGame = () => { 
        const section = document.querySelector('#dice'); if (!section) return;
        const rollButton = section.querySelector('#dice-roll');
        const exitGameButton = section.querySelector('#dice-exit-game');
        const resultElement = section.querySelector('#dice-result');
        const diceFaces = ['âš€', 'âš', 'âš‚', 'âšƒ', 'âš„', 'âš…'];

        const resetDiceRollGame = () => {
            if(resultElement) updateElementText(resultElement, '--');
        };

        if(rollButton) rollButton.addEventListener('click', async () => { 
            const user = auth.currentUser;
            if (!user||!user.emailVerified) {updateElementText(resultElement, '--'); if(resultElement) resultElement.textContent = 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ.'; return;}
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(resultElement, isBanned ? 'Ù…Ø­Ø¸ÙˆØ±!' : 'ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }

            const roll = Math.floor(Math.random() * 6);
            updateElementText(resultElement, diceFaces[roll]);
            playSound('snd-click');
        });
        if(exitGameButton) exitGameButton.addEventListener('click', () => {
            playSound('snd-click');
            resetDiceRollGame();
            if (auth.currentUser && auth.currentUser.emailVerified) window.location.hash = 'game-launcher';
        });
        
        const observerDice = new MutationObserver((mutationsList) => {
             for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (section.classList.contains('active')) {
                        resetDiceRollGame(); 
                    }
                }
            }
        });
        if (section) observerDice.observe(section, { attributes: true });
        resetDiceRollGame();
      };
      
      const initMathQuizGame = () => { 
        const section = document.querySelector('#math'); if (!section) return;
        const startButton = section.querySelector('#math-start');
        const exitGameButton = section.querySelector('#math-exit-game');
        const questionArea = section.querySelector('.question-area');
        const answerInput = section.querySelector('#math-answer');
        const submitButton = section.querySelector('#math-submit');
        const resultElement = section.querySelector('.result');
        const inputGroupDiv = section.querySelector('.input-group');
        let correctAnswer; let gameActiveMath = false;

        const resetMathQuizGame = () => {
            showHideElement(startButton, true);
            showHideElement(exitGameButton, false);
            showHideElement(questionArea, false);
            showHideElement(inputGroupDiv, false); 
            if(resultElement) updateElementText(resultElement, '--');
            if(answerInput) answerInput.value = '';
            gameActiveMath = false;
        };

        const generateQuestion = () => { const num1 = Math.floor(Math.random() * 10) + 1; const num2 = Math.floor(Math.random() * 10) + 1; correctAnswer = num1 + num2; if(questionArea) questionArea.textContent = `${num1} + ${num2} = ?`; if(answerInput) answerInput.value = ''; if(resultElement) updateElementText(resultElement, '--'); };
        
        const startGame = async () => { 
            const user = auth.currentUser;
            if (!user || !user.emailVerified) { if(resultElement) updateElementText(resultElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return; }
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(resultElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            
            gameActiveMath = true;
            showHideElement(startButton, false); showHideElement(exitGameButton, true);
            showHideElement(questionArea, true); showHideElement(inputGroupDiv, true, 'block'); 
            generateQuestion(); if(answerInput) answerInput.focus(); playSound('snd-click');
        };
        const checkAnswer = async () => { 
            const user = auth.currentUser;
            if (!user || !user.emailVerified || !answerInput || !resultElement) { if(resultElement) updateElementText(resultElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return; } 
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(resultElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            if (!gameActiveMath) return; const userAnswer = parseInt(answerInput.value); if (isNaN(userAnswer)) { updateElementText(resultElement, 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­.', 'error'); return; } if (userAnswer === correctAnswer) { updateElementText(resultElement, 'ØµØ­ÙŠØ­! ğŸ‰', 'success'); playSound('snd-win'); setTimeout(() => {  if (gameActiveMath && section.classList.contains('active') && auth.currentUser && auth.currentUser.emailVerified) generateQuestion();  }, 1500); } else { updateElementText(resultElement, `Ø®Ø·Ø£. Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: ${correctAnswer}`, 'error'); playSound('snd-lose'); }  if(answerInput) {answerInput.value = ''; answerInput.focus(); } };

        if(startButton) startButton.addEventListener('click', startGame);
        if(submitButton) submitButton.addEventListener('click', checkAnswer);
        if(answerInput) answerInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && gameActiveMath) checkAnswer(); });
        if(exitGameButton) exitGameButton.addEventListener('click', () => {
            playSound('snd-click');
            resetMathQuizGame();
            if (auth.currentUser && auth.currentUser.emailVerified) window.location.hash = 'game-launcher';
        });
        
        const observerMath = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (section.classList.contains('active')) {
                        if (!gameActiveMath) resetMathQuizGame();
                    } else {
                        if (gameActiveMath) resetMathQuizGame();
                    }
                }
            }
        });
        if (section) observerMath.observe(section, { attributes: true });
        resetMathQuizGame();
      };

      const initGuessNumberGame = () => { 
        const section = document.querySelector('#guessnum'); if (!section) return;
        const startButton = section.querySelector('#guessnum-start');
        const exitGameButton = section.querySelector('#guessnum-exit-game');
        const inputField = section.querySelector('#guessnum-input');
        const submitButton = section.querySelector('#guessnum-submit');
        const resultElement = section.querySelector('.result');
        const messageElement = section.querySelector('.message');
        const inputGroupDiv = section.querySelector('.input-group');
        let secretNumber, attempts; let gameActiveGuessNum = false;
        const maxAttempts = 7;

        const resetGuessNumberGame = () => {
            showHideElement(startButton, true);
            showHideElement(exitGameButton, false);
            showHideElement(inputGroupDiv, false);
            if(inputField) inputField.value = '';
            if(messageElement) updateElementText(messageElement, `Ø®Ù…Ù† Ø±Ù‚Ù…Ù‹Ø§ Ø¨ÙŠÙ† 1 Ùˆ 100.`);
            if(resultElement) updateElementText(resultElement, '--');
            disableElement(submitButton, false); 
            disableElement(inputField, false);   
            gameActiveGuessNum = false;
        };

        const startGame = async () => { 
            const user = auth.currentUser;
            if (!user || !user.emailVerified) { if(resultElement) updateElementText(resultElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return; }
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(resultElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            
            gameActiveGuessNum = true; secretNumber = Math.floor(Math.random() * 100) + 1; attempts = 0; showHideElement(startButton, false); showHideElement(exitGameButton, true); showHideElement(inputGroupDiv, true, 'block'); if(inputField) inputField.value = ''; if(messageElement) updateElementText(messageElement, `Ø®Ù…Ù† Ø±Ù‚Ù…Ù‹Ø§ Ø¨ÙŠÙ† 1 Ùˆ 100. Ù„Ø¯ÙŠÙƒ ${maxAttempts} Ù…Ø­Ø§ÙˆÙ„Ø§Øª.`); if(resultElement) updateElementText(resultElement, '--'); if(inputField) inputField.focus(); disableElement(submitButton, false); disableElement(inputField, false); playSound('snd-click'); };
        
        const checkGuess = async () => { 
            const user = auth.currentUser;
            if (!user || !user.emailVerified || !inputField || !resultElement || !messageElement) { if(resultElement) updateElementText(resultElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return; } 
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(resultElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            if (!gameActiveGuessNum) return; const guess = parseInt(inputField.value); if (isNaN(guess) || guess < 1 || guess > 100) { updateElementText(resultElement, 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø¨ÙŠÙ† 1 Ùˆ 100.', 'error'); return; } attempts++; if (guess === secretNumber) { updateElementText(resultElement, `Ø£Ø­Ø³Ù†Øª! Ù„Ù‚Ø¯ Ø®Ù…Ù†Øª Ø§Ù„Ø±Ù‚Ù… ${secretNumber} ÙÙŠ ${attempts} Ù…Ø­Ø§ÙˆÙ„Ø§Øª.`, 'success'); playSound('snd-win'); if(messageElement) updateElementText(messageElement, 'Ø§Ø¶ØºØ· "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©" Ù„Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.'); showHideElement(startButton, true); showHideElement(exitGameButton, false); disableElement(submitButton, true); disableElement(inputField, true); gameActiveGuessNum = false; } else { playSound('snd-click'); const remainingAttempts = maxAttempts - attempts; if (remainingAttempts <= 0) { updateElementText(resultElement, `Ù„Ù„Ø£Ø³Ù Ø§Ù†ØªÙ‡Øª Ù…Ø­Ø§ÙˆÙ„Ø§ØªÙƒ. Ø§Ù„Ø±Ù‚Ù… Ø§Ù„ØµØ­ÙŠØ­ ÙƒØ§Ù† ${secretNumber}.`, 'error'); playSound('snd-lose'); if(messageElement) updateElementText(messageElement, 'Ø§Ø¶ØºØ· "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©" Ù„Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.'); showHideElement(startButton, true); showHideElement(exitGameButton, false); disableElement(submitButton, true); disableElement(inputField, true); gameActiveGuessNum = false; } else { updateElementText(resultElement, guess < secretNumber ? 'Ø£Ø¹Ù„Ù‰!' : 'Ø£Ù‚Ù„!', 'info'); if(messageElement) updateElementText(messageElement, `Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…ØªØ¨Ù‚ÙŠØ©: ${remainingAttempts}`); } } if(inputField) { inputField.value = ''; inputField.focus(); } };
        
        if(startButton) startButton.addEventListener('click', startGame);
        if(submitButton) submitButton.addEventListener('click', checkGuess);
        if(inputField) inputField.addEventListener('keypress', (e) => { if (e.key === 'Enter' && gameActiveGuessNum) checkGuess(); });
        if(exitGameButton) exitGameButton.addEventListener('click', () => {
            playSound('snd-click');
            resetGuessNumberGame();
            if (auth.currentUser && auth.currentUser.emailVerified) window.location.hash = 'game-launcher';
        });

        const observerGuess = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (section.classList.contains('active')) {
                        if (!gameActiveGuessNum) resetGuessNumberGame();
                    } else {
                        if (gameActiveGuessNum) resetGuessNumberGame();
                    }
                }
            }
        });
        if (section) observerGuess.observe(section, { attributes: true });
        resetGuessNumberGame();
      };

      const initBigSmallGame = () => { 
        const section = document.querySelector('#bigsmall'); if (!section) return;
        const startButton = section.querySelector('#bigsmall-start');
        const exitGameButton = section.querySelector('#bigsmall-exit-game');
        const questionArea = section.querySelector('.question-area');
        const answerInput = section.querySelector('#bigsmall-answer');
        const submitButton = section.querySelector('#bigsmall-submit');
        const resultElement = section.querySelector('.result');
        const inputGroupDiv = section.querySelector('.input-group');
        let num1, num2, biggerNum; let gameActiveBigSmall = false;

        const resetBigSmallGame = () => {
            showHideElement(startButton, true);
            showHideElement(exitGameButton, false);
            showHideElement(questionArea, false);
            showHideElement(inputGroupDiv, false);
            if(answerInput) answerInput.value = '';
            if(resultElement) updateElementText(resultElement, '--');
            gameActiveBigSmall = false;
        };

        const generateNumbers = () => { num1 = Math.floor(Math.random() * 100) + 1; do { num2 = Math.floor(Math.random() * 100) + 1; } while (num1 === num2);  biggerNum = Math.max(num1, num2); if(questionArea) questionArea.textContent = `Ø£ÙŠ Ø§Ù„Ø±Ù‚Ù…ÙŠÙ† Ø£ÙƒØ¨Ø±: ${num1} Ø£Ù… ${num2}ØŸ`; if(answerInput) answerInput.value = ''; if(resultElement) updateElementText(resultElement, '--'); };
        
        const startGame = async () => { 
            const user = auth.currentUser;
            if (!user || !user.emailVerified) { if(resultElement) updateElementText(resultElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return; }
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(resultElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            
            gameActiveBigSmall = true; showHideElement(startButton, false); showHideElement(exitGameButton, true); showHideElement(questionArea, true); showHideElement(inputGroupDiv, true, 'block'); generateNumbers(); if(answerInput) answerInput.focus(); playSound('snd-click'); };
        
        const checkAnswer = async () => { 
            const user = auth.currentUser;
            if (!user || !user.emailVerified || !answerInput || !resultElement) { if(resultElement) updateElementText(resultElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return; } 
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(resultElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            if (!gameActiveBigSmall) return; const userAnswer = parseInt(answerInput.value); if (isNaN(userAnswer)) { updateElementText(resultElement, 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù….', 'error'); return; } if (userAnswer === biggerNum) { updateElementText(resultElement, 'ØµØ­ÙŠØ­! ğŸ‰', 'success'); playSound('snd-win');  setTimeout(() => {  if (gameActiveBigSmall && section.classList.contains('active') && auth.currentUser && auth.currentUser.emailVerified) generateNumbers(); }, 1500); } else { updateElementText(resultElement, `Ø®Ø·Ø£. Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø£ÙƒØ¨Ø± ÙƒØ§Ù† ${biggerNum}.`, 'error'); playSound('snd-lose'); } if(answerInput) {answerInput.value = ''; answerInput.focus();} };
        
        if(startButton) startButton.addEventListener('click', startGame);
        if(submitButton) submitButton.addEventListener('click', checkAnswer);
        if(answerInput) answerInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && gameActiveBigSmall) checkAnswer(); });
        if(exitGameButton) exitGameButton.addEventListener('click', () => {
            playSound('snd-click');
            resetBigSmallGame();
            if (auth.currentUser && auth.currentUser.emailVerified) window.location.hash = 'game-launcher';
        });

        const observerBigSmall = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (section.classList.contains('active')) {
                        if (!gameActiveBigSmall) resetBigSmallGame();
                    } else {
                        if (gameActiveBigSmall) resetBigSmallGame();
                    }
                }
            }
        });
        if (section) observerBigSmall.observe(section, { attributes: true });
        resetBigSmallGame();
      };

      const initTypingTestGame = () => { 
        const section = document.querySelector('#typing'); if (!section) return;
        const startButton = section.querySelector('#typing-start');
        const exitGameButton = section.querySelector('#typing-exit-game');
        const textToTypeElement = section.querySelector('.text-to-type');
        const inputField = section.querySelector('#typing-input');
        const submitButton = section.querySelector('#typing-submit'); 
        const statusElement = section.querySelector('.status');
        const inputGroupDiv = section.querySelector('.input-group');
        const sampleTexts = [ "Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø³Ø±ÙŠØ¹. Ø­Ø§ÙˆÙ„ Ø£Ù† ØªÙƒØªØ¨ Ù‡Ø°Ù‡ Ø§Ù„Ø¬Ù…Ù„Ø© Ø¨Ø¯Ù‚Ø© ÙˆØ³Ø±Ø¹Ø©.", "Ù…Ù…Ø§Ø±Ø³Ø© Ø§Ù„ÙƒØªØ§Ø¨Ø© Ø¨Ø§Ù†ØªØ¸Ø§Ù… ØªØ­Ø³Ù† Ù…Ù† Ù…Ù‡Ø§Ø±ØªÙƒ Ø¨Ø´ÙƒÙ„ Ù…Ù„Ø­ÙˆØ¸.", "Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ© ÙˆØ³ÙŠÙ„Ø© Ø±Ø§Ø¦Ø¹Ø© Ù„Ù„ØªØ±ÙÙŠÙ‡ ÙˆØªÙ†Ù…ÙŠØ© Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ø°Ù‡Ù†ÙŠØ©.", "Ø§Ù„Ø¨Ø±Ù…Ø¬Ø© Ù‡ÙŠ Ù„ØºØ© Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ØŒ ÙˆØªØ¹Ù„Ù…Ù‡Ø§ ÙŠÙØªØ­ Ø¢ÙØ§Ù‚Ø§Ù‹ ÙˆØ§Ø³Ø¹Ø©.", "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙŠØªØ·ÙˆØ± Ø¨Ø³Ø±Ø¹Ø© ÙˆÙŠØºÙŠØ± Ø­ÙŠØ§ØªÙ†Ø§ Ø§Ù„ÙŠÙˆÙ…ÙŠØ©." ];
        let currentTextToType = ""; let startTime; let gameActiveTyping = false;

        const resetTypingTestGame = () => {
            showHideElement(startButton, true);
            showHideElement(exitGameButton, false);
            showHideElement(textToTypeElement, false);
            showHideElement(inputGroupDiv, false); 
            if(inputField) inputField.value = '';
            disableElement(inputField, false); 
            disableElement(submitButton, false); 
            if(statusElement) updateElementText(statusElement, 'Ø§Ø¶ØºØ· "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±"');
            gameActiveTyping = false;
        };

        const startGame = async () => { 
            const user = auth.currentUser;
            if (!user || !user.emailVerified) { if(statusElement) updateElementText(statusElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return; }
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(statusElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            
            gameActiveTyping = true; currentTextToType = sampleTexts[Math.floor(Math.random() * sampleTexts.length)]; if(textToTypeElement) textToTypeElement.textContent = currentTextToType; if(inputField) inputField.value = ''; showHideElement(startButton, false); showHideElement(exitGameButton, true); showHideElement(textToTypeElement, true); showHideElement(inputGroupDiv, true, 'block');  disableElement(inputField, false); disableElement(submitButton, false); if(statusElement) updateElementText(statusElement, 'Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒØªØ§Ø¨Ø©...'); if(inputField) inputField.focus(); startTime = new Date(); playSound('snd-click'); };
        
        const checkTyping = async () => { 
            const user = auth.currentUser;
            if (!user || !user.emailVerified || !inputField || !textToTypeElement || !statusElement) { if(statusElement) updateElementText(statusElement, 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ù„Ù„Ø¹Ø¨.', 'info'); return; } 
            const isBanned = await checkIfUserIsBanned(user.uid);
            const phoneIsVerified = await checkUserPhoneVerified(user.uid);
            if (isBanned || !phoneIsVerified) { 
                updateElementText(statusElement, isBanned ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ±!' : 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡Ø§ØªÙÙƒ!', 'error'); 
                if(isBanned) auth.signOut(); 
                window.location.hash = 'login'; return; 
            }
            if(!gameActiveTyping) return; const typedText = inputField.value; const originalText = textToTypeElement.textContent;  const endTime = new Date(); const timeTaken = (endTime - startTime) / 1000;  if (typedText.length < originalText.length && typedText !== originalText) { updateElementText(statusElement, 'Ø£ÙƒÙ…Ù„ Ø§Ù„Ù†Øµ Ø£ÙˆÙ„Ø§Ù‹ Ø«Ù… Ø§Ø¶ØºØ· ØªØ­Ù‚Ù‚.'); playSound('snd-lose'); return; } let errors = 0; for (let i = 0; i < originalText.length; i++) { if (i >= typedText.length || typedText[i] !== originalText[i]) { errors++; } } if (typedText.length > originalText.length) {  errors += (typedText.length - originalText.length); } const words = originalText.split(/\s+/).filter(Boolean).length; const wpm = timeTaken > 0 ? Math.round((words / timeTaken) * 60) : 0; const accuracy = originalText.length > 0 ? Math.round(((originalText.length - errors) / originalText.length) * 100) : 0;  updateElementText(statusElement, `Ø§Ù„ÙˆÙ‚Øª: ${timeTaken.toFixed(1)} Ø«Ø§Ù†ÙŠØ©, Ø§Ù„Ø³Ø±Ø¹Ø©: ${wpm} Ùƒ/Ø¯, Ø§Ù„Ø¯Ù‚Ø©: ${Math.max(0, accuracy)}%, Ø§Ù„Ø£Ø®Ø·Ø§Ø¡: ${errors}`); playSound(accuracy >= 80 ? 'snd-win' : 'snd-lose'); showHideElement(startButton, true); showHideElement(exitGameButton, false); disableElement(inputField, true); disableElement(submitButton, true); gameActiveTyping = false; };
        
        if(startButton) startButton.addEventListener('click', startGame);
        if(submitButton) submitButton.addEventListener('click', checkTyping);
        if(exitGameButton) exitGameButton.addEventListener('click', () => {
            playSound('snd-click');
            resetTypingTestGame();
            if (auth.currentUser && auth.currentUser.emailVerified) window.location.hash = 'game-launcher';
        });

        const observerTyping = new MutationObserver((mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (section.classList.contains('active')) {
                        if (!gameActiveTyping) resetTypingTestGame();
                    } else {
                        if (gameActiveTyping) resetTypingTestGame();
                    }
                }
            }
        });
        if (section) observerTyping.observe(section, { attributes: true });
        resetTypingTestGame();
      };

      initXOGame(); 
      initRPSGame(); 
      initClickTargetGame(); 
      initReactionTestGame(); 
      initDiceRollGame(); 
      initMemoryGame(); 
      initMathQuizGame(); 
      initGuessNumberGame(); 
      initBigSmallGame(); 
      initTypingTestGame();

      showSectionByHash(); 
    });
  </script>
</body>
</html>
